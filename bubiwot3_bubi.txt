// BUBIWOT v3 Protocol Smart Contract Pseudocode
// Deployed on: The BUBIWOT Appchain (Cosmos-SDK)
// This contract outlines the "on-chain constitution" for a sovereign digital commons.

// =================================================================
// Contract State
// =================================================================

STATE.config: {
  // ... other config from v1 ...
  proposal_bond_amount: Uint, // BUBI required to create a governance proposal
  proposal_voting_period_blocks: Uint,
  build_submission_period_blocks: Uint, // NEW: How long builders have to submit hashes
  async_recovery_period_blocks: Uint, // NEW: How long an async recovery request stays open
  device_liveness_grace_period_blocks: Uint, // NEW: How long a device can be inactive before account is frozen
  auction_period_blocks: Uint, // How often auctions can be started
  ubi_claim_period_blocks: Uint, // The cooldown period for UBI claims
  ubi_claim_cap_per_period: Uint, // Max total UBI that can be claimed in a period
  treasury_revenue_split: { // Governed policy for revenue allocation
    to_staker_rewards: Decimal, // e.g., 0.80 (80%)
    to_swf: Decimal,            // e.g., 0.20 (20%)
  }
}

// -- Core State --
STATE.accounts: Map<PublicKey, Account>
STATE.pending_guardian_replacements: Map<PublicKey, Map<PublicKey, GuardianReplacementRequest>>
STATE.pending_bubi_unstakes: Map<PublicKey, UnstakeRequest>
STATE.pending_async_recoveries: Map<PublicKey, AsynchronousRecoveryRequest> // NEW
STATE.accumulated_bubi_for_auction: Uint // Fees collected for the next auction
STATE.last_auction_start_block: Uint

// -- Governance State --
STATE.proposals: Map<ProposalId, Proposal>
STATE.alliances: Map<String, Alliance> // Record of formal protocol alliances
STATE.code_reviews: Map<ProposalId, List<CodeReview>> // Staked reviews for code proposals
STATE.registered_watchtowers: Map<PublicKey, Watchtower> // Staked entities that can report validators
STATE.registered_builders: Map<PublicKey, Builder> // NEW: Staked entities that build the protocol
STATE.build_submissions: Map<ProposalId, List<BuildSubmission>> // NEW: Tracks submitted build hashes for code proposals
STATE.capability_grants: Map<GrantId, CapabilityGrant> // For ZK-OAuth flows
STATE.used_grant_nullifiers: Map<Bytes, Bool> // For stateless, one-time use of capabilities

// -- Infrastructure State --
STATE.registry: Map<String, RegistryRecord> // On-chain DNS for client/RPC resolution

// -- Developer Economy State --
STATE.bounties: Map<BountyId, Bounty>

// -- Treasury, SWF & Oracle State --
STATE.auctions: Map<AuctionId, TreasuryAuction>
STATE.bids: Map<AuctionId, List<Bid>>
STATE.treasury_assets: Map<String, Uint> Holds all protocol-owned assets from fees and auctions. e.g., {"btc": 10e8, "usdc_on_eth": 5000e6}
STATE.swf_assets: Map<String, Uint> //  The Sovereign Wealth Fund's strategic assets.
STATE.distributable_rewards: Map<String, Uint> //  Pool of assets ready to be claimed by stakers.
STATE.pending_successions: Map<PublicKey, SuccessionRequest> //  For account inheritance.
STATE.used_vc_nullifiers: Map<Bytes, Bool> // Global nullifier set for Verifiable Credentials to prevent replay.
STATE.oracle_consumers: Map<ChainID, Map<Address, OracleConsumer>> // Whitelisted external contracts authorized to call pay_and_post_cr.
STATE.attestation_registry: Map<PublicKey, Map<AttestationType, Attestation>> // Stores attestations linked to a user's identity.
STATE.external_links: Map<PublicKey, Map<ChainID, Address>> // Links BUBIWOT pubkeys to addresses on other chains.
STATE.reverse_external_links: Map<ChainID, Map<Address, PublicKey>> //  Efficient reverse lookup for the oracle.


// -- Data Structures --

// NEW: Canonical account status, derived from verification and liveness evidence.
AccountStatus: Enum("FRESH", "ATTESTED", "FROZEN")

AccountPolicy: {
  // Defines rules for who can perform actions on this account, like becoming a guardian.
  // This structure can be extended to support complex, composable rules for both
  // attestation and recovery (e.g. requiring attestations from multiple user-defined groups).
  min_attestor_reputation: Uint,
  min_attestor_stake: Uint,
  // NEW: Attestors must themselves be backed by specific evidence.
  attestor_must_be_peer_verified: Bool,
  attestor_min_device_count: Uint,
}

// REMOVED: The VerificationLevel enum is replaced by explicit evidence records.

// NEW: Record for each hardware-verified device.
DeviceRecord: {
  fingerprint_hash: Bytes,
  added_block: Uint,
  last_seen_block: Uint, // NEW: Updated when the device is used to sign a tx.
  is_active: Bool,
}

// NEW: Record of a successful peer-verification event.
PeerVerificationRecord: {
  verification_block: Uint,
  policy_hash: Bytes, // The policy used for this verification
  attestor_commitment_hash: Bytes, // A commitment to the set of attestors
}

// --- NEW: Structured Data for Atomic Metrics ---
// These organized structs will replace the looser `activity_metrics` and `security_metrics`.

VerificationEvidence: {
  peer_verification: Option<PeerVerificationRecord>,
  verified_devices: Map<FingerprintHash, DeviceRecord>,
}

GuardianMetrics: {
  guardian_count: Uint,
  guardian_of_count: Uint, // How many accounts list this user as guardian.
  guardian_liveness_ratio: Decimal, // % of this user's guardians with recent heartbeats.
  guardian_set_avg_reputation: Uint, // Average "guardian" reputation of this user's chosen guardians.
  reciprocity_score: Decimal, // % of guardians who have this user as a guardian in return.
  key_rotations_lifetime: Uint, // NEW: from metrics.txt, good security hygiene metric
}

LivenessMetrics: {
  creation_block: Uint, // NEW: from metrics.txt, useful for account age
  last_activity_block: Uint,
  tx_count_30d: Uint,
  governance_votes_90d: Uint,
  session_regularity_score: Uint, // 0-100 score of activity consistency.
}

ReputationMetrics: {
  scores: Map<String, Uint>, // e.g., {"general": 100, "developer": 50, "guardian": 20, "creator": 5}
  review_acceptance_rate: Decimal, // For developers: % of code reviews on proposals that ultimately passed.
  successful_bounties_completed: Uint,
}

EconomicMetrics: {
  bubi_staked_age_days: Uint, // Average age of staked BUBI.
  auction_participation_count_90d: Uint,
  auction_win_count_90d: Uint,
  treasury_bounties_claimed_count: Uint,
  bounties_funded_lifetime: Uint, // NEW: from metrics.txt
  capability_grants_issued_count: Uint,
}

SecurityMetrics: {
  times_slashed_lifetime: Uint,
  sybil_reports_against_count: Uint,
  successful_reports_by_user: Uint, // How many Sybil accounts has this user successfully reported?
  failed_recoveries_as_user: Uint,
  failed_recoveries_as_guardian: Uint,
  succession_policy_set: Bool, // Added from consumer doc
  active_companion_device_count: Uint, // NEW
}
// --- End NEW Structs ---

SocialGraphMetrics: { // For broader social interactions beyond guardians
  trust_distance_from_genesis: Uint, // Shortest path (in attestations) to a genesis/foundation member.
  trust_vector_commitment: Option<Bytes>, // NEW: Merkle commitment to a personalized trust vector (e.g., PageRank)
  nostr_total_zaps_received_value: Uint, // Value-based interactions from linked Nostr ID.
  nostr_unique_zappers_count: Uint,
  external_address_count: Uint, // NEW: from metrics.txt
}

GovernanceMetrics: {
  proposals_submitted: Uint,
  proposals_passed: Uint,
  vote_participation_rate_90d: Decimal, // % of proposals voted on in last 90 days.
  vote_agreement_rate_90d: Decimal, // % of votes that were on the winning side.
  is_delegating_vote: Bool,
  delegated_voting_power: Uint, // How much voting power is delegated TO this user.
  review_stakes_placed: Uint,
}

DataEconomyMetrics: {
  data_vault_size_bytes: Uint, // ZK-provable size of their encrypted data vault.
  active_capability_grants: Uint,
  data_lease_income_lifetime: Uint, // Total BUBI earned from leasing data.
  data_pool_participations: Uint, // Number of privacy-preserving data pools the user is part of.
}

// NEW: Data structure for a user's sovereign Bitcoin vault
TssBtcVault: {
  // NOTE: This high-security vault requires the user to have completed the
  // one-time, interactive Bottom-Up Secret Sharing (BUSS) setup with their guardians
  // to ensure full recoverability of the master key.
  btc_pubkey: Bytes,
  btc_address: String,
  status: Enum("ACTIVE", "LOCKED"),
  pending_tx_nonce: Uint,
}

Account: {
  owner_pubkey: PublicKey,
  status: AccountStatus, // NEW: The account's current lifecycle state.
  guardians: Set<PublicKey>,
  recovery_threshold: Uint,
  staked_btc_info: BtcStakeInfo,
  bubi_balance: Uint,
  bubi_staked: Uint,
  
  // --- REVISED: Verification Evidence in a dedicated struct ---
  verification_evidence: VerificationEvidence,
  // --- End REVISED ---

  humanity_proof_nullifier_set: Set<Bytes>, // Prevents replay of attestor credentials
  device_fingerprint_hash: Option<Bytes>, // For binding account to hardware
  companion_devices: Set<PublicKey>, // For session redundancy
  public_recovery_data: Option<Bytes>,
  last_claim_block: Uint, // For UBI
  last_btc_reward_claim_block: Uint, // For BTC fee share
  policy: AccountPolicy,
  succession_policy: Option<SuccessionPolicy>,
  // --- NEW: Atomic Metrics for Composable Identity ---
  // A Merkle root of all verifiable metrics for this account.
  // This allows for efficient ZK-proofs of specific facts without revealing all data.
  // The full metrics data is stored/computed by the contract and updated on relevant actions.
  metrics_root: Bytes,
  metrics_version: Uint,

  // Key metrics are also stored directly for direct, non-ZK queries.
  // These are a subset of the data committed to the metrics_root and are now highly structured.
  guardian_metrics: GuardianMetrics,
  liveness: LivenessMetrics,
  reputation: ReputationMetrics,
  economic: EconomicMetrics,
  security: SecurityMetrics,
  // --- Start NEW Additions ---
  social_graph: SocialGraphMetrics,
  governance: GovernanceMetrics,
  data_economy: DataEconomyMetrics,
  // --- End NEW Additions ---
  last_activity_block: Uint, //  Updated on any user-initiated transaction.
  guardian_pubkey_for_others: Option<PublicKey>,
  last_guardian_heartbeat_block: Uint, // For guardian proof-of-liveness
  btc_payout_address: Option<String>,

  // NEW: Optional, user-managed sovereign vault
  managed_btc_vault: Option<TssBtcVault>,
}

Proposal: {
  id: ProposalId,
  proposer: PublicKey,
  title: String,
  description_hash: Bytes, // Hash of off-chain description
  merkle_root_of_voters: Bytes, // Snapshot of eligible voters
  vote_counts: { yes: Uint, no: Uint, abstain: Uint },
  used_nullifiers: Set<Bytes>,
  end_block: Uint,
  proposal_bond: Uint,
  status: Enum("PENDING_VOTE", "PASSED", "REJECTED", "EXECUTED", "PENDING_BUILD"),
  payload: ProposalPayload,
  verified_build_hash: Option<Bytes>, // NEW: Stores the consensus-verified build hash
}

ProposalPayload: Enum {
  UpdateCodeCommit({ repo: String, commit_hash: String }),
  UpdateRegistryRecord({ name: String, targets: List<String> }),
  RegisterApplication({ // EXPANDED for Sovereign App Store
    name: String, 
    description_hash: Bytes, 
    targets: List<String>,
    developer_payout_address: Address,
    protocol_fee_permille: Uint, // e.g., 50 for 5%
  }),
  CreateBounty({ title: String, description_hash: Bytes, amount: Uint, currency: String, bounty_id: BountyId }),
  SpendFromTreasury({ recipient: Address, amount: Uint, currency: String }), // To manage community funds
  FreezeAccount({ target_pubkey: PublicKey, reason_hash: Bytes }), // NEW: Governance action to freeze a compromised/malicious account.
  SlashValidator({ validator_address: Address, evidence_hash: Bytes, reporter_pubkey: PublicKey }), // Reporter can be a watchtower
  ReportBug({ faulty_proposal_id: ProposalId, bug_description_hash: Bytes }), // For bug bounty payouts and slashing negligent reviewers
  AuthorizeOracleConsumer({ chain_id: ChainID, consumer_address: Address, fee_per_query: Uint, currency: String }), // NEW
  UpdateTreasuryConfig({ new_split: { to_staker_rewards: Decimal, to_swf: Decimal } }), //  Adjust revenue allocation.
  ExecuteSWFStrategy({
    strategy_id: String, // e.g., "ETH_YIELD_FARM_V1"
    strategy_description_hash: Bytes,
    transactions: List<GenericTxPayload> // A list of concrete, executable cross-chain transactions
  }),  // Deploy capital from the SWF.
  FormAlliance({ // For forming on-chain diplomatic and economic partnerships.
    partner_protocol_id: String, // e.g., "Lido", "Uniswap"
    terms_hash: Bytes, // Off-chain hash of the human-readable agreement
    alliance_details: {
      asset_swap: Option<{
        bubi_to_send: Uint,
        partner_asset_to_receive: String,
        partner_asset_amount: Uint,
      }>,
      joint_liquidity: Option<{
        pool_address: Address, // e.g., a Uniswap V3 pool
        bubi_to_provide: Uint,
        partner_asset_to_provide: Uint,
      }>,
      reciprocal_governance: Option<{
        our_voting_commitment_hash: Bytes,
        their_voting_commitment_hash: Bytes,
      }>
    }
  }),
  VoteInExternalDAO({ //  To direct the SWF's voting power in other protocols.
    proposal_id_on_external_chain: String,
    external_chain_id: ChainID,
    governance_contract_address: Address,
    vote_option: Bytes,
    justification_hash: Bytes,
  }),
  Text,
}

CodeReview: {
  reviewer_pubkey: PublicKey,
  review_stake: Uint,
  approved: Bool,
  comment_hash: Option<Bytes>,
  total_btc_proceeds: Option<Uint>,
}

RegistryRecord: {
  owner_contract: Address, // e.g., The address of the Governance Module
  targets: List<String>, // e.g., ["bafybe... (content hash)", "https://..."]
  btc_lock_tx_proof: Bytes, // Proof their BTC is locked in the TSS escrow
}

Bounty: {
  id: BountyId,
  creator: PublicKey,
  amount: Uint,
  currency: String,
  status: Enum("OPEN", "FULFILLED"),
  fulfilling_proposal_id: Option<ProposalId>,
  fulfiller: Option<PublicKey>,
}

Watchtower: {
  pubkey: PublicKey,
  stake_amount: Uint,
  registration_block: Uint,
}

TreasuryAuction: {
  id: AuctionId,
  bubi_amount: Uint,
  end_block: Uint,
  status: Enum("OPEN", "SETTLED"),
  // Settlement info
  clearing_price_btc_per_bubi: Option<Decimal>,
  total_btc_proceeds: Option<Uint>,
}

Bid: {
  bidder_pubkey: PublicKey,
  // Bidders specify the max price they are willing to pay and the total BTC they are bidding.
  // This allows the contract to calculate how much BUBI they get at the clearing price.
  max_price_btc_per_bubi: Decimal,
  total_btc_to_spend: Uint,
  btc_lock_tx_proof: Bytes, // Proof their BTC is locked in the TSS escrow
}

OracleConsumer: { //  Defines the terms for an authorized oracle user.
  fee_per_query: Uint,
  currency: String, // The asset they pay in (e.g., "usdc_on_eth")
  is_active: Bool,
}

GenericTxPayload: { // Represents a transaction to be executed on an external chain by the protocol's TSS wallet.
  target_chain: ChainID,
  target_address: Address, // e.g., A Uniswap router or Aave lending pool
  value: Uint,
  calldata: Bytes, // The encoded function call (e.g., for a swap, deposit, or stake)
}

CapabilityGrant: { // For ZK-OAuth flows. A user's on-chain consent to an off-chain request.
  grant_id: GrantId,
  granter_pubkey: PublicKey, // The user granting permission
  grantee_address: Address, // The dApp or service receiving permission
  capability: Enum {
      SignPayload({ hash: Bytes }), // Sign an arbitrary piece of data
      ExecuteTx({ target_contract: Address, calldata: Bytes, value: Uint }), // Execute a BUBIWOT-chain transaction
      ReadDataVault({ path_hash: Bytes }), // Grant read access to a part of the data vault
      WriteDataVault({ path_hash: Bytes }), // Grant write access
  },
  request_hash: Bytes, // Hash of the off-chain CapabilityRequest from Nostr.
  expiry_block: Uint,
  is_revoked: Bool,
}

SuccessionPolicy: { // Defines the rules for account inheritance.
  heirs: Set<PublicKey>,
  threshold: Uint, // Number of heirs required to approve succession.
  inactivity_period_blocks: Uint, // How long the account must be inactive to initiate.
  succession_timelock_blocks: Uint, // Cooldown after initiation before succession can be finalized.
}

SuccessionRequest: { //  An active succession attempt.
  initiated_by: PublicKey, // The heir who started the process.
  new_owner_pubkey: PublicKey, // The new public key that will control the account.
  confirmed_heirs: Set<PublicKey>,
  initiation_block: Uint,
}

Alliance: { // Represents a formal, on-chain partnership with another protocol.
  partner_protocol_id: String,
  alliance_start_block: Uint,
  terms_hash: Bytes,
  status: Enum("ACTIVE", "DISSOLVED"),
  reciprocal_agreements: List<String>, // e.g., ["JOINT_LIQUIDITY_UNISWAP_V3_BUBI_ETH", "GOV_NON_AGGRESSION_PACT"]
}

// --- NEW Data Structures for Verifiable Builds ---
Builder: {
  pubkey: PublicKey,
  stake_amount: Uint,
  registration_block: Uint,
  metadata_url: String, // e.g., URL with info about their build service
}

BuildSubmission: {
  builder_pubkey: PublicKey,
  build_hash: Bytes,
  submission_block: Uint,
}
// --- End NEW Data Structures ---

// --- NEW Data Structure for Asynchronous Recovery ---
AsynchronousRecoveryRequest: {
  target_account_pubkey: PublicKey,
  // The ephemeral public key of the new device, used to encrypt shares.
  recovery_pubkey: PublicKey, 
  // Map of guardian pubkey to their encrypted share.
  contributed_shares: Map<PublicKey, Bytes>,
  expiry_block: Uint,
}
// --- End NEW Data Structure ---


// =================================================================
// Core Account & Economy Functions (MVP)
// (Largely similar to previous versions: register_account, set_recovery_info, attest_for_account, report_sybil, stake_bubi, claim_ubi, etc.)
// =================================================================

// NOTE: This logical group of functions represents the 'Account Hub (bubi-hub)' from the architecture docs.

// The `attest_for_account` function is removed in favor of a private, ZK-based flow.

// NEW function to link a hardware-backed device fingerprint to an account.
FUNCTION add_verified_device(device_fingerprint_hash: Bytes):
  user_pubkey = sender
  user_account = STATE.accounts.get(user_pubkey)
  ASSERT user_account is not None, "Account not found"
  // A real implementation would add checks to ensure this hash is globally unique.
  ASSERT user_account.verification_evidence.verified_devices.get(device_fingerprint_hash) is None, "Device already registered"

  device_record = DeviceRecord {
    fingerprint_hash: device_fingerprint_hash,
    added_block: current_block,
    last_seen_block: current_block,
    is_active: True,
  }
  user_account.verification_evidence.verified_devices.set(device_fingerprint_hash, device_record)

  // Update account status if conditions are met
  _update_account_status(user_account)

  STATE.accounts.set(user_pubkey, user_account)
  EMIT Event("DeviceAdded", { owner: user_pubkey, hash: device_fingerprint_hash })

// NEW function to be called periodically to claim Universal Basic Income
FUNCTION claim_ubi():
  // The core function for users to receive their Universal Basic Income.
  user_pubkey = sender
  user_account = STATE.accounts.get(user_pubkey)
  ASSERT user_account is not None, "Account not found"

  // UBI eligibility requires the highest level of assurance, represented by the ATTESTED status.
  ASSERT user_account.status == "ATTESTED", "Account must be in ATTESTED state to claim UBI"

  // Check cooldown period
  ASSERT current_block >= user_account.last_claim_block + STATE.config.ubi_claim_period_blocks, "Claim period has not passed"
  
  // A real implementation would add checks against a global claim cap for the period.
  ubi_amount = _calculate_ubi_for_period() // A function to determine the amount for this period.
  
  user_account.bubi_balance += ubi_amount
  user_account.last_claim_block = current_block
  
  STATE.accounts.set(user_pubkey, user_account)
  EMIT Event("UBIClaimed", { owner: user_pubkey, amount: ubi_amount })


// Allows a user to become peer-verified by providing a ZK-proof that they have
// received attestations from peers who satisfy the user's on-chain policy.
FUNCTION claim_peer_verification(zk_proof: Bytes):
  // Pre-conditions
  user_pubkey = sender
  user_account = STATE.accounts.get(user_pubkey)
  ASSERT user_account is not None, "Account not found"
  ASSERT user_account.verification_evidence.peer_verification is None, "User is already peer-verified. Must revoke first."

  // The ZK-SNARK verifier checks the proof.
  // The proof's public inputs would include a hash of the user's policy and a set of nullifiers
  // for the attestors' credentials, proving they haven't been used for this purpose before.
  public_inputs = ZkSnarkVerifier.get_public_inputs(zk_proof)
  policy_hash = hash(user_account.policy)
  ASSERT public_inputs.policy_hash == policy_hash, "Proof does not match account policy"
  
  // The verifier contract internally checks the proof against a state root of all accounts
  // to confirm that the hidden attestors meet the policy requirements (stake, reputation, etc).
  ASSERT ZkSnarkVerifier.verify(zk_proof, get_current_state_root()) is True

  // Prevent replay attacks by ensuring attestor credentials can only be used once per user claim.
  for nullifier in public_inputs.attestor_nullifiers:
    ASSERT nullifier is not in user_account.humanity_proof_nullifier_set
    user_account.humanity_proof_nullifier_set.add(nullifier)

  // Create the evidence record
  verification_record = PeerVerificationRecord {
    verification_block: current_block,
    policy_hash: policy_hash,
    attestor_commitment_hash: hash(public_inputs.attestor_nullifiers),
  }
  user_account.verification_evidence.peer_verification = Some(verification_record)
  
  // Update account status if conditions are met
  _update_account_status(user_account)
  
  STATE.accounts.set(user_pubkey, user_account)
  EMIT Event("PeerVerificationCompleted", { owner: user_pubkey })


FUNCTION update_guardian_key(new_guardian_pubkey: PublicKey):
  // Allows a user to rotate the dedicated key they use to act as a guardian for others.
  // This action is authorized by their primary account key (sender).
  // Pre-conditions
  user_pubkey = sender
  user_account = STATE.accounts.get(user_pubkey)
  ASSERT user_account is not None, "Account not found"

  // Update the guardian key
  user_account.guardian_pubkey_for_others = Some(new_guardian_pubkey)

  STATE.accounts.set(user_pubkey, user_account)
  EMIT Event("GuardianKeyUpdated", { owner: user_pubkey, new_key: new_guardian_pubkey })


FUNCTION register_account(owner_pubkey, btc_payout_address: Option<String>, btc_staking_tx_proof):
  // ... (Same as before, but initializes new fields) ...
  new_account = Account {
    // ...
    verification_evidence: VerificationEvidence {
      peer_verification: None,
      verified_devices: Map(),
    },
    reputation: ReputationMetrics { scores: Map(), ... },
    // ... initialize other metric structs with default/zero values ...
    metrics_root: get_empty_metrics_root(),
    metrics_version: 1,
    // ...
    managed_btc_vault: None,
  }
  STATE.accounts.set(owner_pubkey, new_account)
  EMIT Event("AccountRegistered", { owner: owner_pubkey })


FUNCTION register_watchtower(stake_amount: Uint):
  // Allows any account to stake BUBI and become a watchtower, eligible for rewards from slashing.
  // Pre-conditions
  watchtower_pubkey = sender
  watchtower_account = STATE.accounts.get(watchtower_pubkey)
  ASSERT watchtower_account is not None, "Account not found"
  ASSERT watchtower_account.status == "ATTESTED", "Must be in ATTESTED state to register as a watchtower"
  ASSERT watchtower_account.bubi_balance >= stake_amount, "Insufficient stake"
  ASSERT STATE.registered_watchtowers.get(watchtower_pubkey) is None, "Already registered"

  // Lock stake from account balance
  watchtower_account.bubi_balance -= stake_amount

  // Create watchtower record
  watchtower = Watchtower {
    pubkey: watchtower_pubkey,
    stake_amount: stake_amount,
    registration_block: current_block,
  }

  STATE.registered_watchtowers.set(watchtower_pubkey, watchtower)
  STATE.accounts.set(watchtower_pubkey, watchtower_account)
  EMIT Event("WatchtowerRegistered", { pubkey: watchtower_pubkey, stake: stake_amount })


// NEW: Allows an account to stake BUBI and become a builder.
FUNCTION register_builder(stake_amount: Uint, metadata_url: String):
  // Pre-conditions
  builder_pubkey = sender
  builder_account = STATE.accounts.get(builder_pubkey)
  ASSERT builder_account is not None, "Account not found"
  ASSERT builder_account.status == "ATTESTED", "Must be in ATTESTED state to register as a builder"
  ASSERT builder_account.bubi_balance >= stake_amount, "Insufficient stake"
  ASSERT STATE.registered_builders.get(builder_pubkey) is None, "Already registered"

  // Lock stake
  builder_account.bubi_balance -= stake_amount

  // Create builder record
  builder = Builder {
    pubkey: builder_pubkey,
    stake_amount: stake_amount,
    registration_block: current_block,
    metadata_url: metadata_url,
  }

  STATE.registered_builders.set(builder_pubkey, builder)
  STATE.accounts.set(builder_pubkey, builder_account)
  EMIT Event("BuilderRegistered", { pubkey: builder_pubkey, stake: stake_amount })


// =================================================================
// Governance Functions (MVP)
// =================================================================

// Called by a user to create a new governance proposal. Requires a bond.
FUNCTION create_proposal(title: String, description_hash: Bytes, payload: ProposalPayload):
  // Pre-conditions
  proposer_pubkey = sender
  proposer_account = STATE.accounts.get(proposer_pubkey)
  ASSERT proposer_account.bubi_balance >= STATE.config.proposal_bond_amount, "Insufficient bond"
  // GOVERNANCE GATING: Proposals can only be created by fully attested users.
  ASSERT proposer_account.status == "ATTESTED", "Account must be in ATTESTED state to create proposals"

  // Take the bond
  proposer_account.bubi_balance -= STATE.config.proposal_bond_amount

  // Create the proposal
  proposal_id = generate_new_proposal_id()
  proposal = Proposal {
    id: proposal_id,
    proposer: proposer_pubkey,
    title: title,
    description_hash: description_hash,
    // REVISED: The voter set is defined as users with both peer and device verification.
    merkle_root_of_voters: generate_merkle_root_of_fully_verified_users(), // On-the-fly snapshot
    vote_counts: { yes: 0, no: 0, abstain: 0 },
    used_nullifiers: Set(),
    end_block: current_block + STATE.config.proposal_voting_period_blocks,
    proposal_bond: STATE.config.proposal_bond_amount,
    status: "PENDING_VOTE",
    payload: payload,
  }

  // If payload is CreateBounty, create the bounty object and lock funds
  if payload is CreateBounty:
    bounty_details = payload.details
    ASSERT proposer_account.bubi_balance >= bounty_details.amount // Check funds for bounty itself
    proposer_account.bubi_balance -= bounty_details.amount
    bounty = Bounty {
      id: bounty_details.bounty_id,
      creator: proposer_pubkey,
      amount: bounty_details.amount,
      currency: bounty_details.currency,
      status: "OPEN",
    }
    STATE.bounties.set(bounty_details.bounty_id, bounty)

  STATE.proposals.set(proposal_id, proposal)
  STATE.accounts.set(proposer_pubkey, proposer_account)
  EMIT Event("ProposalCreated", { id: proposal_id, proposer: proposer_pubkey })


// A user casts a private vote using a ZK-proof.
FUNCTION cast_private_vote(proposal_id, zk_proof: Bytes):
  // Pre-conditions
  proposal = STATE.proposals.get(proposal_id)
  ASSERT proposal is not None and proposal.status == "PENDING_VOTE"
  ASSERT current_block < proposal.end_block

  // ZK-SNARK Verifier checks the proof. The proof's public inputs contain the nullifier and the vote option.
  public_inputs = ZkSnarkVerifier.get_public_inputs(zk_proof)
  nullifier = public_inputs.nullifier
  vote_option = public_inputs.vote_option

  // Verify the proof against the voter set merkle root stored in the proposal
  ASSERT ZkSnarkVerifier.verify(zk_proof, proposal.merkle_root_of_voters) is True
  
  // Prevent double-voting
  ASSERT nullifier is not in proposal.used_nullifiers
  proposal.used_nullifiers.add(nullifier)
  
  // Tally the vote
  proposal.vote_counts[vote_option] += 1
  
  STATE.proposals.set(proposal_id, proposal)
  EMIT Event("PrivateVoteCast", { proposal_id: proposal_id })


// After voting period ends, anyone can trigger proposal finalization.
FUNCTION finalize_proposal(proposal_id):
  proposal = STATE.proposals.get(proposal_id)
  ASSERT proposal is not None and proposal.status == "PENDING_VOTE"
  ASSERT current_block >= proposal.end_block

  // Determine winner
  if proposal.vote_counts.yes > proposal.vote_counts.no:
    // If it's a code proposal, it doesn't pass immediately. It needs a build.
    if proposal.payload is UpdateCodeCommit:
      proposal.status = "PENDING_BUILD"
      // Note: Bond is NOT returned yet. It's held until successful execution.
    else:
      proposal.status = "PASSED"
      // Return bond to proposer for non-code proposals
      proposer_account = STATE.accounts.get(proposal.proposer)
      proposer_account.bubi_balance += proposal.proposal_bond
      STATE.accounts.set(proposal.proposer, proposer_account)
  else:
    proposal.status = "REJECTED"
    // Bond is returned even on rejection, unless explicitly slashed for malice via another proposal.
    proposer_account = STATE.accounts.get(proposal.proposer)
    proposer_account.bubi_balance += proposal.proposal_bond
    STATE.accounts.set(proposal.proposer, proposer_account)
  
  STATE.proposals.set(proposal_id, proposal)
  EMIT Event("ProposalFinalized", { id: proposal_id, status: proposal.status })


// After a proposal has passed, it can be executed.
FUNCTION execute_proposal(proposal_id):
  proposal = STATE.proposals.get(proposal_id)
  ASSERT proposal is not None and proposal.status == "PASSED"

  // Execute based on payload
  payload = proposal.payload
  if payload is UpdateRegistryRecord:
    // This is the only way to update the on-chain registry
    _update_registry_record(payload.name, payload.targets)
  if payload is UpdateCodeCommit:
    // The execution is an on-chain event signaling the new canonical commit.
    // Validator services act on this event.
    EMIT Event("CanonicalCodeUpdated", { repo: payload.repo, commit_hash: payload.commit_hash })
    // Award reputation to the proposer
    proposer_account = STATE.accounts.get(proposal.proposer)
    proposer_account.reputation.scores["developer"] += 10
    STATE.accounts.set(proposal.proposer, proposer_account)
  if payload is SpendFromTreasury:
      // In a real implementation, this would likely have a time-lock.
      // For now, it directly triggers a transfer from a protocol-owned treasury account.
      _transfer_from_treasury(payload.recipient, payload.amount, payload.currency)
  if payload is FreezeAccount: // NEW
    target_account = STATE.accounts.get(payload.target_pubkey)
    if target_account is not None:
      target_account.status = "FROZEN"
      STATE.accounts.set(payload.target_pubkey, target_account)
      EMIT Event("AccountFrozen", { pubkey: payload.target_pubkey, reason: "GovernanceAction" })
  if payload is SlashValidator:
    // This is a governance-enforced action to penalize a validator for misbehavior
    // (e.g., censorship proven by watchtowers). The actual slashing logic
    // would be handled by the underlying staking module of the Cosmos SDK.
    // A portion of the slashed funds should be rewarded to the reporter.
    ASSERT STATE.registered_watchtowers.get(payload.reporter_pubkey) is not None, "Reporter is not a registered watchtower"
    EMIT Event("ValidatorSlashProposed", {
      validator: payload.validator_address,
      evidence: payload.evidence_hash,
      reporter: payload.reporter_pubkey
    })
  if payload is ReportBug:
    // Execute bug bounty logic
    _process_bug_report(payload.faulty_proposal_id, proposal.proposer)

  proposal.status = "EXECUTED"
  STATE.proposals.set(proposal_id, proposal)


// --- NEW Functions for Verifiable Build Workflow ---

// Allows a registered builder to submit their build hash for a code proposal.
FUNCTION submit_build(proposal_id: ProposalId, build_hash: Bytes):
  // Pre-conditions
  builder_pubkey = sender
  ASSERT STATE.registered_builders.get(builder_pubkey) is not None, "Not a registered builder"
  
  proposal = STATE.proposals.get(proposal_id)
  ASSERT proposal is not None and proposal.status == "PENDING_BUILD", "Proposal is not awaiting a build"
  ASSERT current_block < proposal.end_block + STATE.config.build_submission_period_blocks, "Build submission period is over"

  // Store the submission
  submission = BuildSubmission {
    builder_pubkey: builder_pubkey,
    build_hash: build_hash,
    submission_block: current_block,
  }
  submissions = STATE.build_submissions.get(proposal_id) or []
  submissions.append(submission)
  STATE.build_submissions.set(proposal_id, submissions)
  EMIT Event("BuildSubmitted", { proposal_id: proposal_id, builder: builder_pubkey, hash: build_hash })


// After the build submission period, this finalizes the proposal by verifying the build hash via stake-weighted consensus.
FUNCTION certify_and_execute_code_proposal(proposal_id: ProposalId):
  // Pre-conditions
  proposal = STATE.proposals.get(proposal_id)
  ASSERT proposal is not None and proposal.status == "PENDING_BUILD", "Proposal not awaiting build"
  ASSERT current_block >= proposal.end_block + STATE.config.build_submission_period_blocks, "Build submission period not over"

  // Tally stake behind each submitted build hash
  submissions = STATE.build_submissions.get(proposal_id) or []
  stake_per_hash = Map<Bytes, Uint>()
  builders_per_hash = Map<Bytes, List<PublicKey>>()

  for sub in submissions:
    builder = STATE.registered_builders.get(sub.builder_pubkey)
    if builder is not None:
      current_stake = stake_per_hash.get(sub.build_hash) or 0
      stake_per_hash.set(sub.build_hash, current_stake + builder.stake_amount)
      
      current_builders = builders_per_hash.get(sub.build_hash) or []
      current_builders.append(sub.builder_pubkey)
      builders_per_hash.set(sub.build_hash, current_builders)

  // Find the winning hash (the one with the most stake)
  winning_hash = stake_per_hash.keys().max_by(key => stake_per_hash.get(key))
  ASSERT winning_hash is not None, "No build submissions found"
  
  // Slash builders who submitted incorrect hashes and reward the winners
  // (In a real implementation, rewards would be calculated from a protocol pool or slashing proceeds)
  for hash, builders in builders_per_hash.items():
    if hash != winning_hash:
      for builder_pubkey in builders:
        _slash_builder(builder_pubkey, "SubmittedIncorrectBuild")
    else:
      for builder_pubkey in builders:
        _reward_builder(builder_pubkey, "SubmittedCorrectBuild")

  // --- Final Execution ---
  proposal.verified_build_hash = Some(winning_hash)
  proposal.status = "EXECUTED"
  STATE.proposals.set(proposal_id, proposal)

  // Return bond to the original proposer
  proposer_account = STATE.accounts.get(proposal.proposer)
  proposer_account.bubi_balance += proposal.proposal_bond
  STATE.accounts.set(proposal.proposer, proposer_account)

  // Emit event for off-chain services and award reputation
  payload = proposal.payload
  EMIT Event("CanonicalCodeUpdated", {
    repo: payload.repo,
    commit_hash: payload.commit_hash,
    build_hash: winning_hash
  })
  proposer_account.reputation.scores["developer"] += 10
  STATE.accounts.set(proposal.proposer, proposer_account)

// --- End NEW Functions ---


// =================================================================
// Developer Economy Functions (MVP)
// =================================================================

// A user stakes BUBI to review a pending code proposal.
FUNCTION review_code_proposal(proposal_id, stake_amount: Uint, approved: Bool, comment_hash: Option<Bytes>):
  // Pre-conditions
  reviewer_pubkey = sender
  reviewer_account = STATE.accounts.get(reviewer_pubkey)
  ASSERT reviewer_account.status == "ATTESTED", "Must be in ATTESTED state to review code"
  proposal = STATE.proposals.get(proposal_id)
  ASSERT proposal.payload is UpdateCodeCommit
  ASSERT reviewer_account.bubi_balance >= stake_amount

  // Lock stake
  reviewer_account.bubi_balance -= stake_amount

  // Create and store review
  review = CodeReview {
    reviewer_pubkey: reviewer_pubkey,
    review_stake: stake_amount,
    approved: approved,
    comment_hash: comment_hash,
  }
  reviews = STATE.code_reviews.get(proposal_id) or []
  reviews.append(review)
  STATE.code_reviews.set(proposal_id, reviews)
  STATE.accounts.set(reviewer_pubkey, reviewer_account)
  EMIT Event("CodeReviewed", { proposal_id: proposal_id, reviewer: reviewer_pubkey, approved: approved })

// (Note: Logic to pay out/slash review stakes would be in `finalize_proposal`)


// =================================================================
// On-Chain Infrastructure & Query Functions (MVP)
// =================================================================

// NOTE: This logical group of functions represents the 'On-Chain Registry (resolver-contract)' from the architecture docs.

// INTERNAL function to update the registry. Can only be called by this contract.
FUNCTION _update_registry_record(name: String, targets: List<String>):
  // In a real implementation, this would also check that the caller is the governance module itself.
  record = STATE.registry.get(name)
  // For MVP, assume record exists. In reality, would need creation/ownership logic.
  record.targets = targets
  STATE.registry.set(name, record)
  EMIT Event("RegistryUpdated", { name: name, new_targets: targets })

// PUBLIC query function for clients to resolve names.
QUERY resolve_name(name: String):
  record = STATE.registry.get(name)
  RETURN record.targets

QUERY get_proposal(proposal_id):
  RETURN STATE.proposals.get(proposal_id)

QUERY get_account(owner_pubkey):
  RETURN STATE.accounts.get(owner_pubkey)

// =================================================================
// Developer Economy & Account Maintenance Functions (MVP)
// =================================================================

// Called by a user to confirm they have reviewed their guardian set, boosting their reputation.
FUNCTION perform_guardian_review():
  // Pre-conditions
  user_pubkey = sender
  user_account = STATE.accounts.get(user_pubkey)
  ASSERT user_account is not None, "Account not found"

  // This function would likely have a cooldown period to prevent spamming.
  // For simplicity, we just increase the reputation score.
  user_account.reputation.scores["guardian"] += 1 // Small reward for good security hygiene
  STATE.accounts.set(user_pubkey, user_account)
  EMIT Event("GuardianSetReviewed", { owner: user_pubkey, new_reputation: user_account.reputation.scores["guardian"] })

// Manages companion devices for session redundancy.
FUNCTION add_companion_device(device_pubkey: PublicKey):
  // Pre-conditions
  user_pubkey = sender
  user_account = STATE.accounts.get(user_pubkey)
  ASSERT user_account is not None, "Account not found"
  // Optional: Could have a limit on number of devices

  user_account.companion_devices.add(device_pubkey)
  STATE.accounts.set(user_pubkey, user_account)
  EMIT Event("CompanionDeviceAdded", { owner: user_pubkey, device: device_pubkey })

FUNCTION remove_companion_device(device_pubkey: PublicKey):
  // Pre-conditions
  user_pubkey = sender
  user_account = STATE.accounts.get(user_pubkey)
  ASSERT user_account is not None, "Account not found"

  user_account.companion_devices.remove(device_pubkey)
  STATE.accounts.set(user_pubkey, user_account)
  EMIT Event("CompanionDeviceRemoved", { owner: user_pubkey, device: device_pubkey })

// Called by a guardian to prove they are online and active.
FUNCTION guardian_heartbeat():
  // Pre-conditions
  guardian_pubkey = sender // This is the user's main key
  guardian_account = STATE.accounts.get(guardian_pubkey)
  ASSERT guardian_account is not None, "Account not found"
  // A user must have opted-in to be a guardian for others by setting a guardian key.
  ASSERT guardian_account.guardian_pubkey_for_others is not None, "User is not an active guardian"
  // Optional: Add a cooldown to prevent spam

  guardian_account.last_guardian_heartbeat_block = current_block
  // Optional: Distribute a small liveness reward
  STATE.accounts.set(guardian_pubkey, guardian_account)
  EMIT Event("GuardianHeartbeat", { guardian: guardian_pubkey, block: current_block })

// Allows a user to remove a guardian who has been inactive for too long.
// This is different from a regular replacement as it might incur a penalty.
FUNCTION slash_inactive_guardian(guardian_to_slash_pubkey: PublicKey):
  user_pubkey = sender
  user_account = STATE.accounts.get(user_pubkey)
  ASSERT user_account is not None
  ASSERT guardian_to_slash_pubkey in user_account.guardians, "Not a guardian for this user"

  guardian_account = STATE.accounts.get(guardian_to_slash_pubkey)
  ASSERT guardian_account is not None

  // Define inactivity threshold (e.g., 1 million blocks)
  INACTIVITY_THRESHOLD_BLOCKS = 1_000_000 
  is_inactive = (current_block - guardian_account.last_guardian_heartbeat_block) > INACTIVITY_THRESHOLD_BLOCKS
  
  ASSERT is_inactive, "Guardian is not inactive"

  // Remove from user's guardian set
  user_account.guardians.remove(guardian_to_slash_pubkey)
  
  // Apply penalty
  // For simplicity, we just reduce reputation. A real implementation could slash a bond.
  guardian_account.reputation.scores["guardian"] -= 10 // Penalty for unresponsiveness
  
  STATE.accounts.set(user_pubkey, user_account)
  STATE.accounts.set(guardian_to_slash_pubkey, guardian_account)
  
  EMIT Event("GuardianSlashedForInactivity", { owner: user_pubkey, slashed_guardian: guardian_to_slash_pubkey })

// --- NEW Account Status Management Functions ---

// INTERNAL helper to transition account status based on evidence.
FUNCTION _update_account_status(account: &mut Account):
  // Conditions for ATTESTED: At least one peer verification and one active device.
  has_peer_verification = account.verification_evidence.peer_verification.is_some()
  has_active_device = account.verification_evidence.verified_devices.values().filter(d => d.is_active).len() > 0

  if account.status == "FRESH" and has_peer_verification and has_active_device:
    account.status = "ATTESTED"
    EMIT Event("AccountAttested", { pubkey: account.owner_pubkey })
  
  // Note: Unfreezing logic is handled in `unfreeze_account` to require explicit user action.

// Called by anyone to check if an account's devices have gone stale, freezing the account if necessary.
FUNCTION check_and_update_account_status(target_pubkey: PublicKey):
  account = STATE.accounts.get(target_pubkey)
  ASSERT account is not None, "Account not found"
  if account.status != "ATTESTED": RETURN // Only attested accounts can be frozen for inactivity.

  is_stale = True
  for device in account.verification_evidence.verified_devices.values():
    if device.is_active and (current_block - device.last_seen_block) < STATE.config.device_liveness_grace_period_blocks:
      is_stale = False
      break
  
  if is_stale:
    account.status = "FROZEN"
    STATE.accounts.set(target_pubkey, account)
    EMIT Event("AccountFrozen", { pubkey: target_pubkey, reason: "DeviceInactivity" })

// Allows a user to unfreeze their account by proving liveness.
FUNCTION unfreeze_account():
  user_pubkey = sender
  account = STATE.accounts.get(user_pubkey)
  ASSERT account is not None, "Account not found"
  ASSERT account.status == "FROZEN", "Account is not frozen"

  // To unfreeze, the user must prove control of an active, registered device.
  // The device fingerprint would be part of the transaction signature context.
  device_fingerprint_hash = get_signer_device_fingerprint()
  device = account.verification_evidence.verified_devices.get(device_fingerprint_hash)
  ASSERT device is not None and device.is_active, "Request must be signed by an active, registered device"

  // Update device liveness and account status
  device.last_seen_block = current_block
  account.status = "ATTESTED"
  
  STATE.accounts.set(user_pubkey, account)
  EMIT Event("AccountUnfrozen", { pubkey: user_pubkey })


// INTERNAL function to process a successful bug report proposal.
FUNCTION _process_bug_report(faulty_proposal_id, bug_reporter_pubkey):
  // Reward the bug reporter
  reporter_account = STATE.accounts.get(bug_reporter_pubkey)
  reporter_account.reputation.scores["developer"] += 50 // Significant reward
  // Potentially pay out a BUBI bounty as well
  STATE.accounts.set(bug_reporter_pubkey, reporter_account)

  // Find and penalize reviewers who approved the faulty proposal
  reviews = STATE.code_reviews.get(faulty_proposal_id)
  for review in reviews:
    if review.approved:
      // Slash the stake of the negligent reviewer
      // The slashed funds could go to the bug reporter or the treasury
      reviewer_account = STATE.accounts.get(review.reviewer_pubkey)
      reviewer_account.reputation.scores["developer"] -= 25 // Penalty
      // The original `review_stake` is slashed (not returned)
      STATE.accounts.set(review.reviewer_pubkey, reviewer_account)
      EMIT Event("ReviewerSlashed", {
        proposal_id: faulty_proposal_id,
        reviewer: review.reviewer_pubkey,
      })

  // NEW: Find and penalize the builders who submitted the faulty build
  if faulty_proposal.verified_build_hash is not None:
    submissions = STATE.build_submissions.get(faulty_proposal_id) or []
    for sub in submissions:
      if sub.build_hash == faulty_proposal.verified_build_hash:
        _slash_builder(sub.builder_pubkey, "BuiltFaultyCode")

// =================================================================
// Capability Grant Functions (ZK-OAuth)
// =================================================================

// Called by an authorized consumer to signal a new capability request.
// The full request lives off-chain on Nostr. This function creates the on-chain pointer.
FUNCTION pay_and_post_cr(user_pubkey: PublicKey, request_nostr_event_id: Bytes, fee: Coin):
  consumer_address = sender
  // Access Control: Ensure the caller is whitelisted via governance.
  consumer = STATE.oracle_consumers.get(get_chain_id())?.get(consumer_address)
  ASSERT consumer is not None and consumer.is_active, "Not an authorized oracle consumer"
  ASSERT fee.amount >= consumer.fee_per_query and fee.denom == consumer.currency, "Incorrect fee"

  // Lock the fee
  _credit_treasury(fee.denom, fee.amount, hash(tx))

  EMIT Event("CapabilityRequestPosted", {
    consumer: consumer_address,
    target_user: user_pubkey,
    request_event_id: request_nostr_event_id
  })

// Allows a user to grant a specific, time-limited capability in response to an off-chain request.
FUNCTION grant_capability(grantee_address: Address, capability: Enum, expiry_duration_blocks: Uint, request_hash: Bytes):
  user_pubkey = sender
  grant_id = generate_new_grant_id(user_pubkey, grantee_address, request_hash)
  ASSERT STATE.capability_grants.get(grant_id) is None, "Capability grant with this request hash already exists"

  grant = CapabilityGrant {
    grant_id: grant_id,
    granter_pubkey: user_pubkey,
    grantee_address: grantee_address,
    capability: capability,
    request_hash: request_hash,
    expiry_block: current_block + expiry_duration_blocks,
    is_revoked: False,
  }
  STATE.capability_grants.set(grant_id, grant)
  EMIT Event("CapabilityGranted", { grant_id: grant_id, granter: user_pubkey, grantee: grantee_address })

// Allows a user to revoke a capability before it expires.
FUNCTION revoke_capability(grant_id: GrantId):
  grant = STATE.capability_grants.get(grant_id)
  ASSERT grant is not None, "Grant not found"
  ASSERT grant.granter_pubkey == sender, "Only granter can revoke"
  
  grant.is_revoked = True
  STATE.capability_grants.set(grant_id, grant)
  EMIT Event("CapabilityRevoked", { grant_id: grant_id })

// Allows a grantee (dApp) to use a capability one time. This is the core settlement function.
// The proof_bundle (containing ZK proofs and guardian signatures) is verified off-chain by the grantee.
// This function only cares about on-chain state: grant validity and usage.
FUNCTION use_capability(grant_id: GrantId, usage_nonce: Bytes):
  grant = STATE.capability_grants.get(grant_id)
  grantee = sender

  // Verify on-chain conditions
  ASSERT grant is not None, "Grant not found"
  ASSERT grant.grantee_address == grantee, "Caller is not the grantee"
  ASSERT grant.is_revoked == False, "Grant has been revoked"
  ASSERT current_block < grant.expiry_block, "Grant has expired"

  // Prevent replay by checking the nullifier
  nullifier = hash(grant_id, usage_nonce)
  ASSERT STATE.used_grant_nullifiers.get(nullifier) is None, "Capability has already been used with this nonce"
  STATE.used_grant_nullifiers.set(nullifier, True)

  // Execute the capability
  capability = grant.capability
  if capability is ExecuteTx:
    // This makes the grant system composable with the rest of the protocol.
    // A dApp can be granted permission to call another function on the user's behalf.
    CALL(target_contract: capability.target_contract, calldata: capability.calldata, value: capability.value)
  // Other capability types like SignPayload are handled off-chain; this on-chain call
  // simply serves as the immutable record that the capability was officially "used".

  EMIT Event("CapabilityUsed", { grant_id: grant_id, grantee: grantee, nullifier: nullifier })


// =================================================================
// Human Oracle & External Integration Functions
// =================================================================

// Allows a user to link their verified BUBIWOT identity to an address on another chain.
// The signature proves ownership of the external address.
FUNCTION link_external_address(chain_id: ChainID, external_address: Address, signature: Bytes):
  // Pre-conditions
  user_pubkey = sender
  user_account = STATE.accounts.get(user_pubkey)
  // To link an external address, user must have at least one piece of strong verification evidence.
  ASSERT user_account is not None, "Account not found"
  ASSERT user_account.verification_evidence.peer_verification.is_some() or user_account.verification_evidence.verified_devices.len() > 0, "User must have device or peer verification to link addresses"
  
  // Verify that the sender actually owns the external address.
  // This would involve a chain-specific signature verification (e.g., EIP-712).
  ASSERT verify_external_signature(chain_id, external_address, user_pubkey, signature) is True
  
  // Store the primary link
  user_links = STATE.external_links.get(user_pubkey) or Map()
  user_links.set(chain_id, external_address)
  STATE.external_links.set(user_pubkey, user_links)

  // Store the reverse link for efficient queries
  chain_links = STATE.reverse_external_links.get(chain_id) or Map()
  chain_links.set(external_address, user_pubkey)
  STATE.reverse_external_links.set(chain_id, chain_links)
  
  EMIT Event("ExternalAddressLinked", { owner: user_pubkey, chain: chain_id, address: external_address })

// PUBLIC query function for external dApps to get a summary of a user's verification evidence.
QUERY get_verification_summary(chain_id: ChainID, external_address: Address, consumer_address: Address):
  // Access Control: Ensure the caller is an authorized oracle consumer.
  consumer = STATE.oracle_consumers.get(chain_id)?.get(consumer_address)
  ASSERT consumer is not None and consumer.is_active, "Not an authorized oracle consumer"
  
  // Perform the efficient lookup
  pubkey = STATE.reverse_external_links.get(chain_id)?.get(external_address)
  if pubkey is None:
    RETURN { has_peer_verification: False, active_device_count: 0 }
    
  account = STATE.accounts.get(pubkey)
  active_devices = account.verification_evidence.verified_devices.values().filter(d => d.is_active).len()
  RETURN {
    has_peer_verification: account.verification_evidence.peer_verification.is_some(),
    active_device_count: active_devices,
    peer_verification_block: account.verification_evidence.peer_verification?.verification_block,
  }

// Verifies a complex, user-generated ZK proof of attributes on behalf of an authorized consuming dApp.
// verifies proofs over a set of arbitrary, atomic facts.
QUERY verify_identity_proof(
  chain_id: ChainID,
  consumer_address: Address,
  user_external_address: Address,
  zk_proof: Bytes,
  public_inputs: {
    // Hash of the specific set of predicates being proven, e.g.,
    // hash([
    //   {metric: "guardian_count", op: "gte", value: 5},
    //   {metric: "times_slashed_lifetime", op: "eq", value: 0}
    // ])
    predicates_hash: Bytes,
    vc_nullifiers: List<Bytes>, // Nullifiers for any Verifiable Credentials used in the proof
  }
):
  // This is a high-value query that enables advanced use cases like reputation-based undercollateralized lending.
  // 1. Access Control: Ensure the caller is an authorized and fee-paying oracle consumer.
  consumer = STATE.oracle_consumers.get(chain_id)?.get(consumer_address)
  ASSERT consumer is not None and consumer.is_active, "Not an authorized oracle consumer"
  // Fee logic would be handled by the relayer before calling this query.

  // 2. Find the user's BUBIWOT account from their external address for context.
  user_pubkey = STATE.reverse_external_links.get(chain_id)?.get(user_external_address)
  ASSERT user_pubkey is not None, "User has no linked BUBIWOT account"
  user_account = STATE.accounts.get(user_pubkey)

  // 3. Prevent replay of Verifiable Credentials used in the proof.
  for nullifier in public_inputs.vc_nullifiers:
    ASSERT STATE.used_vc_nullifiers.get(nullifier) is None, "Verifiable credential has already been used in a proof"
    STATE.used_vc_nullifiers.set(nullifier, True)

  // 4. Verify the ZK proof against the account's current metrics root and the public inputs hash.
  // The proof is generated client-side by the user. It proves that their account's
  // metrics satisfy the predicates without revealing any private data beyond that.
  ASSERT ZkSnarkVerifier.verify(zk_proof, user_account.metrics_root, public_inputs.predicates_hash) is True, "ZK proof verification failed"

  // 5. Return success. The dApp now has a high-integrity, privacy-preserving signal.
  RETURN True

// PUBLIC query function for non-private inspection of an account's metrics.
QUERY get_account_metrics(owner_pubkey: PublicKey):
  account = STATE.accounts.get(owner_pubkey)
  ASSERT account is not None, "Account not found"
  // In a real implementation, this would return a struct of all public metrics.
  RETURN {
    reputation: account.reputation,
    guardian_metrics: account.guardian_metrics,
    liveness: account.liveness,
    economic: account.economic,
    security: account.security,
  }


// =================================================================
// Treasury Auction Functions
// =================================================================

// INTERNAL function called by the bridge/oracle service to credit foreign assets.
// credits the main treasury from any source (e.g., oracle fees).
FUNCTION _credit_treasury(asset_denom: String, amount: Uint, source_tx_hash: Bytes):
  // Access control: only a trusted relayer/bridge entity can call this.
  ASSERT is_caller_bridge_relayer(sender)

  current_balance = STATE.treasury_assets.get(asset_denom) or 0
  STATE.treasury_assets.set(asset_denom, current_balance + amount)
  EMIT Event("TreasuryCredited", { asset: asset_denom, amount: amount, source_tx: source_tx_hash })


// Anyone can kick off a new auction if the auction period has passed.
FUNCTION start_auction():
  // Pre-conditions
  ASSERT current_block > STATE.last_auction_start_block + STATE.config.auction_period_blocks, "Auction period not over"
  bubi_to_auction = STATE.accumulated_bubi_for_auction
  ASSERT bubi_to_auction > 0, "No BUBI fees to auction"

  // Reset accumulator and update timer
  STATE.accumulated_bubi_for_auction = 0
  STATE.last_auction_start_block = current_block

  // Create and store the new auction
  auction_id = generate_new_auction_id()
  auction = TreasuryAuction {
    id: auction_id,
    bubi_amount: bubi_to_auction,
    end_block: current_block + STATE.config.proposal_voting_period_blocks, // Re-use voting period for auction duration
    status: "OPEN",
  }
  STATE.auctions.set(auction_id, auction)
  EMIT Event("AuctionStarted", { id: auction_id, bubi_amount: bubi_to_auction })

// A user places a bid on an open auction.
FUNCTION place_bid(auction_id, max_price_btc_per_bubi: Decimal, total_btc_to_spend: Uint, btc_lock_tx_proof: Bytes):
  // Pre-conditions
  auction = STATE.auctions.get(auction_id)
  ASSERT auction is not None and auction.status == "OPEN", "Auction not open"
  ASSERT current_block < auction.end_block, "Auction has ended"

  // TODO: Verify the btc_lock_tx_proof to ensure the BTC is actually held in escrow by the TSS vault.

  // Store the bid
  bid = Bid {
    bidder_pubkey: sender,
    max_price_btc_per_bubi: max_price_btc_per_bubi,
    total_btc_to_spend: total_btc_to_spend,
    btc_lock_tx_proof: btc_lock_tx_proof,
  }
  bids = STATE.bids.get(auction_id) or []
  bids.append(bid)
  STATE.bids.set(auction_id, bids)
  EMIT Event("BidPlaced", { auction_id: auction_id, bidder: sender })

// After an auction ends, anyone can trigger settlement.
FUNCTION settle_auction(auction_id):
  // Pre-conditions
  auction = STATE.auctions.get(auction_id)
  ASSERT auction is not None and auction.status == "OPEN", "Auction not open for settlement"
  ASSERT current_block >= auction.end_block, "Auction has not ended yet"

  // --- Batch Auction Settlement Logic (Uniform Price) ---
  bids = STATE.bids.get(auction_id) or []
  // Sort bids from highest price to lowest
  sorted_bids = bids.sort(by="max_price_btc_per_bubi", order="desc")
  
  bubi_to_sell = auction.bubi_amount
  clearing_price = 0
  total_btc_proceeds = 0
  
  // Step 1: Find the clearing price. This is the price of the last bid that can be
  // at least partially filled to sell all the BUBI.
  bubi_demand_so_far = 0
  winning_bids = []
  losing_bids = []

  for bid in sorted_bids:
    if bubi_demand_so_far < bubi_to_sell:
      clearing_price = bid.max_price_btc_per_bubi
      // We calculate demand at this bid's price just to see if the auction clears.
      bubi_demanded_at_this_price = bid.total_btc_to_spend / bid.max_price_btc_per_bubi
      bubi_demand_so_far += bubi_demanded_at_this_price
      winning_bids.append(bid)
    else:
      losing_bids.append(bid)
  
  // If auction failed to clear (not enough demand), handle it.
  ASSERT bubi_demand_so_far >= bubi_to_sell, "Auction failed to clear due to insufficient demand"

  // Step 2: Settle all winning bids at the single clearing price.
  bubi_left_to_distribute = bubi_to_sell
  for bid in winning_bids:
      // At the uniform clearing price, how much BUBI can the bidder's locked BTC buy?
      bubi_can_afford = bid.total_btc_to_spend / clearing_price
      
      bubi_to_award = 0
      if bubi_can_afford < bubi_left_to_distribute:
        // Bidder gets all the BUBI they can afford at the clearing price.
        bubi_to_award = bubi_can_afford
      else:
        // This bidder is the last (or only) one, getting a full or partial fill of what's left.
        bubi_to_award = bubi_left_to_distribute
      
      if bubi_to_award <= 0: continue

      actual_btc_to_pay = bubi_to_award * clearing_price
      total_btc_proceeds += actual_btc_to_pay
      bubi_left_to_distribute -= bubi_to_award
      
      // Send BUBI to the winner
      winner_account = STATE.accounts.get(bid.bidder_pubkey)
      winner_account.bubi_balance += bubi_to_award
      STATE.accounts.set(bid.bidder_pubkey, winner_account)
      
      // Emit event for the TSS service to handle BTC movement
      EMIT Event("BidWon", {
          auction_id: auction_id,
          bidder: bid.bidder_pubkey,
          btc_to_protocol: actual_btc_to_pay,
          // The refund is the difference between what they locked and what they paid.
          btc_to_refund: bid.total_btc_to_spend - actual_btc_to_pay
      })

  // Signal TSS to refund all losing bids
  for bid in losing_bids:
      EMIT Event("BidLost", { auction_id: auction_id, bidder: bid.bidder_pubkey })

  // Update auction state
  auction.status = "SETTLED"
  auction.clearing_price_btc_per_bubi = Some(clearing_price)
  auction.total_btc_proceeds = Some(total_btc_proceeds)
  STATE.auctions.set(auction_id, auction)

  // This signals the protocol that new BTC is available for distribution
  EMIT Event("AuctionSettled", { id: auction_id, proceeds_btc: total_btc_proceeds })
  
  // Add auction proceeds to the main treasury
  current_treasury_btc = STATE.treasury_assets.get("btc") or 0
  STATE.treasury_assets.set("btc", current_treasury_btc + total_btc_proceeds)
  
  // Allocate all funds currently in the treasury
  _allocate_treasury_funds()

// INTERNAL function to allocate all assets in the treasury to the SWF and staker rewards pool.
FUNCTION _allocate_treasury_funds():
  split = STATE.config.treasury_revenue_split
  
  for asset, amount in STATE.treasury_assets.items():
    if amount == 0: continue
    
    // Calculate split
    to_swf = amount * split.to_swf
    to_rewards = amount - to_swf // Remainder to rewards to avoid dust
    
    // Add to SWF
    current_swf_balance = STATE.swf_assets.get(asset) or 0
    STATE.swf_assets.set(asset, current_swf_balance + to_swf)
    
    // Add to distributable rewards pool
    current_reward_balance = STATE.distributable_rewards.get(asset) or 0
    STATE.distributable_rewards.set(asset, current_reward_balance + to_rewards)
    
    EMIT Event("TreasuryAllocated", { asset: asset, to_swf: to_swf, to_rewards: to_rewards })

  // Clear the treasury now that it's been allocated
  STATE.treasury_assets = Map()

// =================================================================
// Account Succession & Inheritance Functions
// =================================================================

// Allows a user to define or update their succession policy.
FUNCTION set_succession_policy(policy: SuccessionPolicy):
  user_pubkey = sender
  user_account = STATE.accounts.get(user_pubkey)
  ASSERT user_account is not None, "Account not found"
  ASSERT policy.threshold <= policy.heirs.len(), "Threshold cannot exceed number of heirs"

  user_account.succession_policy = Some(policy)
  user_account.last_activity_block = current_block
  STATE.accounts.set(user_pubkey, user_account)
  EMIT Event("SuccessionPolicySet", { owner: user_pubkey })

// Called by a designated heir to begin the succession process for an inactive account.
FUNCTION initiate_succession(target_account_pubkey: PublicKey, new_owner_pubkey: PublicKey):
  initiator_pubkey = sender
  target_account = STATE.accounts.get(target_account_pubkey)
  ASSERT target_account is not None, "Target account not found"
  ASSERT target_account.succession_policy is not None, "Target account has no succession policy"
  
  policy = target_account.succession_policy
  ASSERT initiator_pubkey in policy.heirs, "Caller is not a designated heir"

  // Check for inactivity
  is_inactive = (current_block - target_account.last_activity_block) > policy.inactivity_period_blocks
  ASSERT is_inactive, "Account is still active"

  // Ensure no succession is already in progress
  ASSERT STATE.pending_successions.get(target_account_pubkey) is None, "Succession already in progress"

  request = SuccessionRequest {
    initiated_by: initiator_pubkey,
    new_owner_pubkey: new_owner_pubkey,
    confirmed_heirs: {initiator_pubkey},
    initiation_block: current_block,
  }
  STATE.pending_successions.set(target_account_pubkey, request)
  EMIT Event("SuccessionInitiated", { target: target_account_pubkey, initiator: initiator_pubkey })

// Called by other heirs to approve an active succession request.
FUNCTION confirm_succession(target_account_pubkey: PublicKey):
  confirmer_pubkey = sender
  request = STATE.pending_successions.get(target_account_pubkey)
  policy = STATE.accounts.get(target_account_pubkey).succession_policy
  ASSERT request is not None, "No succession in progress for this account"
  ASSERT confirmer_pubkey in policy.heirs, "Caller is not a designated heir"
  
  request.confirmed_heirs.add(confirmer_pubkey)
  STATE.pending_successions.set(target_account_pubkey, request)
  EMIT Event("SuccessionConfirmed", { target: target_account_pubkey, confirmer: confirmer_pubkey })

// Called by the original owner to cancel a mistaken or malicious succession attempt.
FUNCTION cancel_succession():
  user_pubkey = sender
  request = STATE.pending_successions.get(user_pubkey)
  ASSERT request is not None, "No succession in progress for this account"

  // This proves the original owner is active and in control.
  STATE.pending_successions.remove(user_pubkey)
  
  account = STATE.accounts.get(user_pubkey)
  account.last_activity_block = current_block // Update activity timestamp
  STATE.accounts.set(user_pubkey, account)

  EMIT Event("SuccessionCancelled", { owner: user_pubkey })

// After conditions are met, anyone can call this to finalize the transfer of the account.
FUNCTION finalize_succession(target_account_pubkey: PublicKey):
  request = STATE.pending_successions.get(target_account_pubkey)
  account = STATE.accounts.get(target_account_pubkey)
  ASSERT request is not None, "No succession in progress"
  
  policy = account.succession_policy
  ASSERT len(request.confirmed_heirs) >= policy.threshold, "Heir threshold not met"
  
  timelock_has_passed = (current_block - request.initiation_block) > policy.succession_timelock_blocks
  ASSERT timelock_has_passed, "Succession timelock has not passed"

  // All checks pass. Transfer ownership.
  // We create a new account record for the new owner, copying the state,
  // and then delete the old one.
  new_owner_pubkey = request.new_owner_pubkey
  ASSERT STATE.accounts.get(new_owner_pubkey) is None, "New owner pubkey already has an account"

  // Copy state to new account, resetting security policies.
  new_account = account
  new_account.owner_pubkey = new_owner_pubkey
  new_account.guardians = Set() // Heirs must set up their own security.
  new_account.companion_devices = Set()
  new_account.succession_policy = None // Must be re-established.
  new_account.last_activity_block = current_block

  STATE.accounts.set(new_owner_pubkey, new_account)
  STATE.accounts.remove(target_account_pubkey)
  STATE.pending_successions.remove(target_account_pubkey)

  EMIT Event("SuccessionFinalized", { old_owner: target_account_pubkey, new_owner: new_owner_pubkey })

  // Emit an event to trigger the transfer of linked external assets.
  // The TSS Executor Service listens for this event and uses the `external_links`
  // mapping to transfer assets on other chains to the heir's corresponding addresses.
  EMIT Event("SuccessionAssetTransferTriggered", {
      deceased_owner: target_account_pubkey,
      heir_owner: new_owner_pubkey
  })

// =================================================================
// Asynchronous Recovery Functions
// =================================================================

// NOTE on the Two-Tiered Recovery Model:
// BUBIWOT supports two complementary recovery mechanisms to balance convenience and security.
//
// 1. Asynchronous Recovery (implemented below): This is the default, user-friendly
//    method for regaining *control* of an account (e.g., rotating the owner key). It is
//    stateful on-chain, allowing guardians to contribute shares at their own convenience.
//    This is sufficient for most day-to-day account management.
//
// 2. Bottom-Up Secret Sharing (BUSS - described in the litepaper): This is a high-security,
//    interactive, and off-chain process for reconstructing the user's *master secret key*.
//    It is a required security "upgrade" for users who want to create and use the
//    `TssBtcVault` for managing Bitcoin, as it ensures the ultimate private key is fully recoverable.

// Called by anyone on behalf of a user who has lost their device.
// This creates an on-chain request that guardians can respond to asynchronously.
FUNCTION initiate_asynchronous_recovery(target_account_pubkey: PublicKey, recovery_pubkey: PublicKey):
  // Pre-conditions
  ASSERT STATE.accounts.get(target_account_pubkey) is not None, "Target account does not exist"
  ASSERT STATE.pending_async_recoveries.get(target_account_pubkey) is None, "Recovery process already initiated for this account"

  // Create and store the recovery request
  request = AsynchronousRecoveryRequest {
    target_account_pubkey: target_account_pubkey,
    recovery_pubkey: recovery_pubkey,
    contributed_shares: Map(),
    expiry_block: current_block + STATE.config.async_recovery_period_blocks,
  }
  STATE.pending_async_recoveries.set(target_account_pubkey, request)

  EMIT Event("AsynchronousRecoveryInitiated", { 
    target: target_account_pubkey, 
    recovery_pubkey: recovery_pubkey,
    expiry: request.expiry_block
  })

// Called by a guardian to contribute their share to an active recovery process.
// The share must be encrypted off-chain with the recovery_pubkey.
FUNCTION contribute_recovery_share(target_account_pubkey: PublicKey, encrypted_share: Bytes):
  // Pre-conditions
  guardian_pubkey = sender
  request = STATE.pending_async_recoveries.get(target_account_pubkey)
  ASSERT request is not None, "No active recovery process for this account"
  ASSERT current_block < request.expiry_block, "Recovery period has expired"

  target_account = STATE.accounts.get(target_account_pubkey)
  ASSERT guardian_pubkey in target_account.guardians, "Sender is not a guardian for the target account"
  ASSERT request.contributed_shares.get(guardian_pubkey) is None, "Guardian has already contributed a share"

  // Store the encrypted share
  request.contributed_shares.set(guardian_pubkey, encrypted_share)
  STATE.pending_async_recoveries.set(target_account_pubkey, request)

  EMIT Event("RecoveryShareContributed", { target: target_account_pubkey, guardian: guardian_pubkey })

// Called by the original owner if they regain access to their account, to prevent a malicious or mistaken recovery.
FUNCTION cancel_asynchronous_recovery():
  // Pre-conditions
  owner_pubkey = sender
  request = STATE.pending_async_recoveries.get(owner_pubkey)
  ASSERT request is not None, "No recovery in progress for this account"

  // The owner proving they are in control is enough to cancel.
  STATE.pending_async_recoveries.remove(owner_pubkey)
  
  // Also update activity to prevent succession attempts
  account = STATE.accounts.get(owner_pubkey)
  account.last_activity_block = current_block
  STATE.accounts.set(owner_pubkey, account)

  EMIT Event("AsynchronousRecoveryCancelled", { owner: owner_pubkey })

// Called by anyone to clean up an expired recovery request from state.
FUNCTION cleanup_asynchronous_recovery(target_account_pubkey: PublicKey):
  request = STATE.pending_async_recoveries.get(target_account_pubkey)
  ASSERT request is not None, "No recovery request to clean up"
  ASSERT current_block >= request.expiry_block, "Recovery request has not expired yet"

  // Remove the expired request
  STATE.pending_async_recoveries.remove(target_account_pubkey)

  EMIT Event("AsynchronousRecoveryCleaned", { target: target_account_pubkey })

// NEW: Called by a user to create their sovereign vault.
FUNCTION create_sovereign_btc_vault():
  user_pubkey = sender
  user_account = STATE.accounts.get(user_pubkey)
  ASSERT user_account is not None, "Account not found"
  ASSERT user_account.managed_btc_vault is None, "Vault already exists"

  // This event signals the off-chain TSS service to perform DKG
  // and then call back to the contract to register the new address.
  EMIT Event("SovereignVaultCreationRequested", { owner: user_pubkey })

// NEW: Called by the TSS service itself to register the newly created vault address.
FUNCTION _register_sovereign_btc_vault(owner_pubkey: PublicKey, btc_pubkey: Bytes, btc_address: String):
  // Access control: only the TSS service's representative on-chain can call this.
  ASSERT is_caller_tss_service(sender)
  user_account = STATE.accounts.get(owner_pubkey)
  ASSERT user_account is not None
  
  vault = TssBtcVault {
    btc_pubkey: btc_pubkey,
    btc_address: btc_address,
    status: "ACTIVE",
    pending_tx_nonce: 0,
  }
  user_account.managed_btc_vault = Some(vault)
  STATE.accounts.set(owner_pubkey, user_account)
  EMIT Event("SovereignVaultCreated", { owner: owner_pubkey, address: btc_address })

// NEW: Called by the user to authorize a spend from their vault.
FUNCTION authorize_btc_spend(recipient_address: String, amount_sats: Uint, fee_rate_sats_per_byte: Uint):
  user_pubkey = sender
  user_account = STATE.accounts.get(user_pubkey)
  ASSERT user_account is not None, "Account not found"
  vault = user_account.managed_btc_vault
  ASSERT vault is not None and vault.status == "ACTIVE", "Vault is not active or does not exist"

  // This event signals the TSS service to construct, sign, and broadcast the Bitcoin transaction.
  EMIT Event("BtcSpendAuthorized", {
    owner: user_pubkey,
    recipient: recipient_address,
    amount: amount_sats,
    fee_rate: fee_rate_sats_per_byte,
    nonce: vault.pending_tx_nonce
  })
  
  // Increment nonce to prevent replay of the same authorization
  vault.pending_tx_nonce += 1
  STATE.accounts.set(user_pubkey, user_account)
