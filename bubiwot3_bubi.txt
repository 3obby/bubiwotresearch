// BUBIWOT v3 Protocol Smart Contract Pseudocode
// Deployed on: The BUBIWOT Appchain (Cosmos-SDK)
// This contract outlines the "on-chain constitution" for a sovereign digital commons.

// =================================================================
// Contract State
// =================================================================

STATE.config: {
  // ... other config from v1 ...
  proposal_bond_amount: Uint, // BUBI required to create a governance proposal
  proposal_voting_period_blocks: Uint,
  auction_period_blocks: Uint, // How often auctions can be started
  ubi_claim_period_blocks: Uint, // The cooldown period for UBI claims
  ubi_claim_cap_per_period: Uint, // Max total UBI that can be claimed in a period
  treasury_revenue_split: { // NEW: Governed policy for revenue allocation
    to_staker_rewards: Decimal, // e.g., 0.80 (80%)
    to_swf: Decimal,            // e.g., 0.20 (20%)
  }
}

// -- Core State --
STATE.accounts: Map<PublicKey, Account>
STATE.pending_guardian_replacements: Map<PublicKey, Map<PublicKey, GuardianReplacementRequest>>
STATE.pending_bubi_unstakes: Map<PublicKey, UnstakeRequest>
STATE.accumulated_bubi_for_auction: Uint // Fees collected for the next auction
STATE.last_auction_start_block: Uint

// -- Governance State --
STATE.proposals: Map<ProposalId, Proposal>
STATE.code_reviews: Map<ProposalId, List<CodeReview>> // Staked reviews for code proposals
STATE.registered_watchtowers: Map<PublicKey, Watchtower> // Staked entities that can report validators

// -- Infrastructure State --
STATE.registry: Map<String, RegistryRecord> // On-chain DNS for client/RPC resolution

// -- Developer Economy State --
STATE.bounties: Map<BountyId, Bounty>

// -- Treasury Auction State --
STATE.auctions: Map<AuctionId, TreasuryAuction>
STATE.bids: Map<AuctionId, List<Bid>>
STATE.treasury_assets: Map<String, Uint> // RENAMED: from cross_chain_vault. Holds all protocol-owned assets from fees and auctions. e.g., {"btc": 10e8, "usdc_on_eth": 5000e6}
STATE.swf_assets: Map<String, Uint> // NEW: The Sovereign Wealth Fund's strategic assets.
STATE.distributable_rewards: Map<String, Uint> // NEW: Pool of assets ready to be claimed by stakers.
STATE.oracle_consumers: Map<ChainID, Map<Address, OracleConsumer>> // NEW: Whitelisted external contracts authorized to use the Human Oracle.
STATE.external_links: Map<PublicKey, Map<ChainID, Address>> // NEW: Links BUBIWOT pubkeys to addresses on other chains.
STATE.reverse_external_links: Map<ChainID, Map<Address, PublicKey>> // NEW: Efficient reverse lookup for the oracle.


// -- Data Structures --

AccountPolicy: {
  // Defines rules for who can perform actions on this account, like becoming a guardian.
  // This structure can be extended to support complex, composable rules for both
  // attestation and recovery (e.g. requiring attestations from multiple user-defined groups).
  min_attestor_reputation: Uint,
  min_attestor_stake: Uint,
  attestor_must_be_human: Bool,
}

Account: {
  owner_pubkey: PublicKey,
  guardians: Set<PublicKey>,
  recovery_threshold: Uint,
  staked_btc_info: BtcStakeInfo,
  bubi_balance: Uint,
  bubi_staked: Uint,
  reputation_score: Uint,
  developer_reputation_score: Uint, // For code contributions
  is_human_verified: Bool,
  humanity_proof_nullifier_set: Set<Bytes>, // Prevents replay of attestor credentials
  device_fingerprint_hash: Option<Bytes>, // For binding account to hardware
  companion_devices: Set<PublicKey>, // For session redundancy
  public_recovery_data: Option<Bytes>,
  last_claim_block: Uint, // For UBI
  last_btc_reward_claim_block: Uint, // For BTC fee share
  policy: AccountPolicy,
  guardian_pubkey_for_others: Option<PublicKey>,
  last_guardian_heartbeat_block: Uint, // For guardian proof-of-liveness
  btc_payout_address: Option<String>,
}

Proposal: {
  id: ProposalId,
  proposer: PublicKey,
  title: String,
  description_hash: Bytes, // Hash of off-chain description
  merkle_root_of_voters: Bytes, // Snapshot of eligible voters
  vote_counts: { yes: Uint, no: Uint, abstain: Uint },
  used_nullifiers: Set<Bytes>,
  end_block: Uint,
  proposal_bond: Uint,
  status: Enum("PENDING_VOTE", "PASSED", "REJECTED", "EXECUTED"),
  payload: ProposalPayload,
}

ProposalPayload: Enum {
  UpdateCodeCommit({ repo: String, commit_hash: String }),
  UpdateRegistryRecord({ name: String, targets: List<String> }),
  CreateBounty({ title: String, description_hash: Bytes, amount: Uint, currency: String, bounty_id: BountyId }),
  SpendFromTreasury({ recipient: Address, amount: Uint, currency: String }), // To manage community funds
  SlashValidator({ validator_address: Address, evidence_hash: Bytes, reporter_pubkey: PublicKey }), // Reporter can be a watchtower
  ReportBug({ faulty_proposal_id: ProposalId, bug_description_hash: Bytes }), // For bug bounty payouts and slashing negligent reviewers
  AuthorizeOracleConsumer({ chain_id: ChainID, consumer_address: Address, fee_per_query: Uint, currency: String }), // NEW
  UpdateTreasuryConfig({ new_split: TreasurySplit, new_params: ... }), // NEW: Adjust revenue allocation and other params.
  ExecuteSWFStrategy({ strategy_hash: Bytes, transactions: List<GenericTxPayload> }), // NEW: Deploy capital from the SWF.
  Text,
}

CodeReview: {
  reviewer_pubkey: PublicKey,
  review_stake: Uint,
  approved: Bool,
  comment_hash: Option<Bytes>,
  total_btc_proceeds: Option<Uint>,
}

RegistryRecord: {
  owner_contract: Address, // e.g., The address of the Governance Module
  targets: List<String>, // e.g., ["ipfs://...", "arweave://..."]
}

Bounty: {
  id: BountyId,
  creator: PublicKey,
  amount: Uint,
  currency: String,
  status: Enum("OPEN", "FULFILLED"),
  fulfilling_proposal_id: Option<ProposalId>,
  fulfiller: Option<PublicKey>,
}

Watchtower: {
  pubkey: PublicKey,
  stake_amount: Uint,
  registration_block: Uint,
}

TreasuryAuction: {
  id: AuctionId,
  bubi_amount: Uint,
  end_block: Uint,
  status: Enum("OPEN", "SETTLED"),
  // Settlement info
  clearing_price_btc_per_bubi: Option<Decimal>,
  total_btc_proceeds: Option<Uint>,
}

Bid: {
  bidder_pubkey: PublicKey,
  // Bidders specify the max price they are willing to pay and the total BTC they are bidding.
  // This allows the contract to calculate how much BUBI they get at the clearing price.
  max_price_btc_per_bubi: Decimal,
  total_btc_to_spend: Uint,
  btc_lock_tx_proof: Bytes, // Proof their BTC is locked in the TSS escrow
}

OracleConsumer: { // NEW: Defines the terms for an authorized oracle user.
  fee_per_query: Uint,
  currency: String, // The asset they pay in (e.g., "usdc_on_eth")
  is_active: Bool,
}

GenericTxPayload: { // NEW: Represents a transaction to be executed on an external chain by the protocol's TSS wallet.
  target_chain: ChainID,
  target_address: Address, // e.g., A Uniswap router
  value: Uint,
  calldata: Bytes, // The encoded function call (e.g., for a swap)
}


// =================================================================
// Core Account & Economy Functions (MVP)
// (Largely similar to previous versions: register_account, set_recovery_info, attest_for_account, report_sybil, stake_bubi, claim_ubi, etc.)
// =================================================================

// The `attest_for_account` function is removed in favor of a private, ZK-based flow.

// Allows a user to become verified by providing a ZK-proof that they have
// received attestations from peers who satisfy the user's on-chain policy.
FUNCTION claim_humanity_with_proof(zk_proof: Bytes, device_fingerprint_hash: Bytes):
  // Pre-conditions
  user_pubkey = sender
  user_account = STATE.accounts.get(user_pubkey)
  ASSERT user_account is not None, "Account not found"
  ASSERT user_account.is_human_verified == False, "User is already verified"

  // The ZK-SNARK verifier checks the proof.
  // The proof's public inputs would include a hash of the user's policy and a set of nullifiers
  // for the attestors' credentials, proving they haven't been used for this purpose before.
  public_inputs = ZkSnarkVerifier.get_public_inputs(zk_proof)
  policy_hash = hash(user_account.policy)
  ASSERT public_inputs.policy_hash == policy_hash, "Proof does not match account policy"
  
  // The verifier contract internally checks the proof against a state root of all accounts
  // to confirm that the hidden attestors meet the policy requirements (stake, reputation, etc).
  ASSERT ZkSnarkVerifier.verify(zk_proof, get_current_state_root()) is True

  // Prevent replay attacks by ensuring attestor credentials can only be used once per user claim.
  for nullifier in public_inputs.attestor_nullifiers:
    ASSERT nullifier is not in user_account.humanity_proof_nullifier_set
    user_account.humanity_proof_nullifiers.add(nullifier)

  // Grant verified status and bind to device
  user_account.is_human_verified = True
  user_account.device_fingerprint_hash = Some(device_fingerprint_hash)
  
  STATE.accounts.set(user_pubkey, user_account)
  EMIT Event("HumanityVerified", { owner: user_pubkey, device_hash: device_fingerprint_hash })


FUNCTION update_guardian_key(new_guardian_pubkey: PublicKey):
  // Allows a user to rotate the dedicated key they use to act as a guardian for others.
  // This action is authorized by their primary account key (sender).
  // Pre-conditions
  user_pubkey = sender
  user_account = STATE.accounts.get(user_pubkey)
  ASSERT user_account is not None, "Account not found"

  // Update the guardian key
  user_account.guardian_pubkey_for_others = Some(new_guardian_pubkey)

  STATE.accounts.set(user_pubkey, user_account)
  EMIT Event("GuardianKeyUpdated", { owner: user_pubkey, new_key: new_guardian_pubkey })


FUNCTION register_account(owner_pubkey, btc_payout_address: Option<String>, btc_staking_tx_proof):
  // ... (Same as before, but initializes new fields) ...
  new_account = Account {
    // ...
    developer_reputation_score: 0,
    // ...
  }
  STATE.accounts.set(owner_pubkey, new_account)
  EMIT Event("AccountRegistered", { owner: owner_pubkey })


FUNCTION register_watchtower(stake_amount: Uint):
  // Allows any account to stake BUBI and become a watchtower, eligible for rewards from slashing.
  // Pre-conditions
  watchtower_pubkey = sender
  watchtower_account = STATE.accounts.get(watchtower_pubkey)
  ASSERT watchtower_account is not None, "Account not found"
  ASSERT watchtower_account.bubi_balance >= stake_amount, "Insufficient stake"
  ASSERT STATE.registered_watchtowers.get(watchtower_pubkey) is None, "Already registered"

  // Lock stake from account balance
  watchtower_account.bubi_balance -= stake_amount

  // Create watchtower record
  watchtower = Watchtower {
    pubkey: watchtower_pubkey,
    stake_amount: stake_amount,
    registration_block: current_block,
  }

  STATE.registered_watchtowers.set(watchtower_pubkey, watchtower)
  STATE.accounts.set(watchtower_pubkey, watchtower_account)
  EMIT Event("WatchtowerRegistered", { pubkey: watchtower_pubkey, stake: stake_amount })


// =================================================================
// Governance Functions (MVP)
// =================================================================

// Called by a user to create a new governance proposal. Requires a bond.
FUNCTION create_proposal(title: String, description_hash: Bytes, payload: ProposalPayload):
  // Pre-conditions
  proposer_pubkey = sender
  proposer_account = STATE.accounts.get(proposer_pubkey)
  ASSERT proposer_account.bubi_balance >= STATE.config.proposal_bond_amount, "Insufficient bond"

  // Take the bond
  proposer_account.bubi_balance -= STATE.config.proposal_bond_amount

  // Create the proposal
  proposal_id = generate_new_proposal_id()
  proposal = Proposal {
    id: proposal_id,
    proposer: proposer_pubkey,
    title: title,
    description_hash: description_hash,
    merkle_root_of_voters: generate_merkle_root_of_verified_humans(), // On-the-fly snapshot
    vote_counts: { yes: 0, no: 0, abstain: 0 },
    used_nullifiers: Set(),
    end_block: current_block + STATE.config.proposal_voting_period_blocks,
    proposal_bond: STATE.config.proposal_bond_amount,
    status: "PENDING_VOTE",
    payload: payload,
  }

  // If payload is CreateBounty, create the bounty object and lock funds
  if payload is CreateBounty:
    bounty_details = payload.details
    ASSERT proposer_account.bubi_balance >= bounty_details.amount // Check funds for bounty itself
    proposer_account.bubi_balance -= bounty_details.amount
    bounty = Bounty {
      id: bounty_details.bounty_id,
      creator: proposer_pubkey,
      amount: bounty_details.amount,
      currency: bounty_details.currency,
      status: "OPEN",
    }
    STATE.bounties.set(bounty_details.bounty_id, bounty)

  STATE.proposals.set(proposal_id, proposal)
  STATE.accounts.set(proposer_pubkey, proposer_account)
  EMIT Event("ProposalCreated", { id: proposal_id, proposer: proposer_pubkey })


// A user casts a private vote using a ZK-proof.
FUNCTION cast_private_vote(proposal_id, zk_proof: Bytes):
  // Pre-conditions
  proposal = STATE.proposals.get(proposal_id)
  ASSERT proposal is not None and proposal.status == "PENDING_VOTE"
  ASSERT current_block < proposal.end_block

  // ZK-SNARK Verifier checks the proof. The proof's public inputs contain the nullifier and the vote option.
  public_inputs = ZkSnarkVerifier.get_public_inputs(zk_proof)
  nullifier = public_inputs.nullifier
  vote_option = public_inputs.vote_option

  // Verify the proof against the voter set merkle root stored in the proposal
  ASSERT ZkSnarkVerifier.verify(zk_proof, proposal.merkle_root_of_voters) is True
  
  // Prevent double-voting
  ASSERT nullifier is not in proposal.used_nullifiers
  proposal.used_nullifiers.add(nullifier)
  
  // Tally the vote
  proposal.vote_counts[vote_option] += 1
  
  STATE.proposals.set(proposal_id, proposal)
  EMIT Event("PrivateVoteCast", { proposal_id: proposal_id })


// After voting period ends, anyone can trigger proposal finalization.
FUNCTION finalize_proposal(proposal_id):
  proposal = STATE.proposals.get(proposal_id)
  ASSERT proposal is not None and proposal.status == "PENDING_VOTE"
  ASSERT current_block >= proposal.end_block

  // Determine winner
  if proposal.vote_counts.yes > proposal.vote_counts.no:
    proposal.status = "PASSED"
    // Return bond to proposer
    proposer_account = STATE.accounts.get(proposal.proposer)
    proposer_account.bubi_balance += proposal.proposal_bond
    STATE.accounts.set(proposal.proposer, proposer_account)
  else:
    proposal.status = "REJECTED"
    // Bond is returned even on rejection, unless explicitly slashed for malice via another proposal.
    proposer_account = STATE.accounts.get(proposal.proposer)
    proposer_account.bubi_balance += proposal.proposal_bond
    STATE.accounts.set(proposal.proposer, proposer_account)
  
  STATE.proposals.set(proposal_id, proposal)
  EMIT Event("ProposalFinalized", { id: proposal_id, status: proposal.status })


// After a proposal has passed, it can be executed.
FUNCTION execute_proposal(proposal_id):
  proposal = STATE.proposals.get(proposal_id)
  ASSERT proposal is not None and proposal.status == "PASSED"

  // Execute based on payload
  payload = proposal.payload
  if payload is UpdateRegistryRecord:
    // This is the only way to update the on-chain registry
    _update_registry_record(payload.name, payload.targets)
  if payload is UpdateCodeCommit:
    // The execution is an on-chain event signaling the new canonical commit.
    // Validator services act on this event.
    EMIT Event("CanonicalCodeUpdated", { repo: payload.repo, commit_hash: payload.commit_hash })
    // Award reputation to the proposer
    proposer_account = STATE.accounts.get(proposal.proposer)
    proposer_account.developer_reputation_score += 10
    STATE.accounts.set(proposal.proposer, proposer_account)
  if payload is SpendFromTreasury:
      // In a real implementation, this would likely have a time-lock.
      // For now, it directly triggers a transfer from a protocol-owned treasury account.
      _transfer_from_treasury(payload.recipient, payload.amount, payload.currency)
  if payload is SlashValidator:
    // This is a governance-enforced action to penalize a validator for misbehavior
    // (e.g., censorship proven by watchtowers). The actual slashing logic
    // would be handled by the underlying staking module of the Cosmos SDK.
    // A portion of the slashed funds should be rewarded to the reporter.
    ASSERT STATE.registered_watchtowers.get(payload.reporter_pubkey) is not None, "Reporter is not a registered watchtower"
    EMIT Event("ValidatorSlashProposed", {
      validator: payload.validator_address,
      evidence: payload.evidence_hash,
      reporter: payload.reporter_pubkey
    })
  if payload is ReportBug:
    // Execute bug bounty logic
    _process_bug_report(payload.faulty_proposal_id, proposal.proposer)

  proposal.status = "EXECUTED"
  STATE.proposals.set(proposal_id, proposal)


// =================================================================
// Developer Economy Functions (MVP)
// =================================================================

// A user stakes BUBI to review a pending code proposal.
FUNCTION review_code_proposal(proposal_id, stake_amount: Uint, approved: Bool, comment_hash: Option<Bytes>):
  // Pre-conditions
  reviewer_pubkey = sender
  reviewer_account = STATE.accounts.get(reviewer_pubkey)
  proposal = STATE.proposals.get(proposal_id)
  ASSERT proposal.payload is UpdateCodeCommit
  ASSERT reviewer_account.bubi_balance >= stake_amount

  // Lock stake
  reviewer_account.bubi_balance -= stake_amount

  // Create and store review
  review = CodeReview {
    reviewer_pubkey: reviewer_pubkey,
    review_stake: stake_amount,
    approved: approved,
    comment_hash: comment_hash,
  }
  reviews = STATE.code_reviews.get(proposal_id) or []
  reviews.append(review)
  STATE.code_reviews.set(proposal_id, reviews)
  STATE.accounts.set(reviewer_pubkey, reviewer_account)
  EMIT Event("CodeReviewed", { proposal_id: proposal_id, reviewer: reviewer_pubkey, approved: approved })

// (Note: Logic to pay out/slash review stakes would be in `finalize_proposal`)


// =================================================================
// On-Chain Infrastructure & Query Functions (MVP)
// =================================================================

// INTERNAL function to update the registry. Can only be called by this contract.
FUNCTION _update_registry_record(name: String, targets: List<String>):
  // In a real implementation, this would also check that the caller is the governance module itself.
  record = STATE.registry.get(name)
  // For MVP, assume record exists. In reality, would need creation/ownership logic.
  record.targets = targets
  STATE.registry.set(name, record)
  EMIT Event("RegistryUpdated", { name: name, new_targets: targets })

// PUBLIC query function for clients to resolve names.
QUERY resolve_name(name: String):
  record = STATE.registry.get(name)
  RETURN record.targets

QUERY get_proposal(proposal_id):
  RETURN STATE.proposals.get(proposal_id)

QUERY get_account(owner_pubkey):
  RETURN STATE.accounts.get(owner_pubkey)

// =================================================================
// Developer Economy & Account Maintenance Functions (MVP)
// =================================================================

// Called by a user to confirm they have reviewed their guardian set, boosting their reputation.
FUNCTION perform_guardian_review():
  // Pre-conditions
  user_pubkey = sender
  user_account = STATE.accounts.get(user_pubkey)
  ASSERT user_account is not None, "Account not found"

  // This function would likely have a cooldown period to prevent spamming.
  // For simplicity, we just increase the reputation score.
  user_account.reputation_score += 1 // Small reward for good security hygiene
  STATE.accounts.set(user_pubkey, user_account)
  EMIT Event("GuardianSetReviewed", { owner: user_pubkey, new_reputation: user_account.reputation_score })

// Manages companion devices for session redundancy.
FUNCTION add_companion_device(device_pubkey: PublicKey):
  // Pre-conditions
  user_pubkey = sender
  user_account = STATE.accounts.get(user_pubkey)
  ASSERT user_account is not None, "Account not found"
  // Optional: Could have a limit on number of devices

  user_account.companion_devices.add(device_pubkey)
  STATE.accounts.set(user_pubkey, user_account)
  EMIT Event("CompanionDeviceAdded", { owner: user_pubkey, device: device_pubkey })

FUNCTION remove_companion_device(device_pubkey: PublicKey):
  // Pre-conditions
  user_pubkey = sender
  user_account = STATE.accounts.get(user_pubkey)
  ASSERT user_account is not None, "Account not found"

  user_account.companion_devices.remove(device_pubkey)
  STATE.accounts.set(user_pubkey, user_account)
  EMIT Event("CompanionDeviceRemoved", { owner: user_pubkey, device: device_pubkey })

// Called by a guardian to prove they are online and active.
FUNCTION guardian_heartbeat():
  // Pre-conditions
  guardian_pubkey = sender // This is the user's main key
  guardian_account = STATE.accounts.get(guardian_pubkey)
  ASSERT guardian_account is not None, "Account not found"
  // A user must have opted-in to be a guardian for others by setting a guardian key.
  ASSERT guardian_account.guardian_pubkey_for_others is not None, "User is not an active guardian"
  // Optional: Add a cooldown to prevent spam

  guardian_account.last_guardian_heartbeat_block = current_block
  // Optional: Distribute a small liveness reward
  STATE.accounts.set(guardian_pubkey, guardian_account)
  EMIT Event("GuardianHeartbeat", { guardian: guardian_pubkey, block: current_block })

// Allows a user to remove a guardian who has been inactive for too long.
// This is different from a regular replacement as it might incur a penalty.
FUNCTION slash_inactive_guardian(guardian_to_slash_pubkey: PublicKey):
  user_pubkey = sender
  user_account = STATE.accounts.get(user_pubkey)
  ASSERT user_account is not None
  ASSERT guardian_to_slash_pubkey in user_account.guardians, "Not a guardian for this user"

  guardian_account = STATE.accounts.get(guardian_to_slash_pubkey)
  ASSERT guardian_account is not None

  // Define inactivity threshold (e.g., 1 million blocks)
  INACTIVITY_THRESHOLD_BLOCKS = 1_000_000 
  is_inactive = (current_block - guardian_account.last_guardian_heartbeat_block) > INACTIVITY_THRESHOLD_BLOCKS
  
  ASSERT is_inactive, "Guardian is not inactive"

  // Remove from user's guardian set
  user_account.guardians.remove(guardian_to_slash_pubkey)
  
  // Apply penalty
  // For simplicity, we just reduce reputation. A real implementation could slash a bond.
  guardian_account.reputation_score -= 10 // Penalty for unresponsiveness
  
  STATE.accounts.set(user_pubkey, user_account)
  STATE.accounts.set(guardian_to_slash_pubkey, guardian_account)
  
  EMIT Event("GuardianSlashedForInactivity", { owner: user_pubkey, slashed_guardian: guardian_to_slash_pubkey })

// INTERNAL function to process a successful bug report proposal.
FUNCTION _process_bug_report(faulty_proposal_id, bug_reporter_pubkey):
  // Reward the bug reporter
  reporter_account = STATE.accounts.get(bug_reporter_pubkey)
  reporter_account.developer_reputation_score += 50 // Significant reward
  // Potentially pay out a BUBI bounty as well
  STATE.accounts.set(bug_reporter_pubkey, reporter_account)

  // Find and penalize reviewers who approved the faulty proposal
  reviews = STATE.code_reviews.get(faulty_proposal_id)
  for review in reviews:
    if review.approved:
      // Slash the stake of the negligent reviewer
      // The slashed funds could go to the bug reporter or the treasury
      reviewer_account = STATE.accounts.get(review.reviewer_pubkey)
      reviewer_account.developer_reputation_score -= 25 // Penalty
      // The original `review_stake` is slashed (not returned)
      STATE.accounts.set(review.reviewer_pubkey, reviewer_account)
      EMIT Event("ReviewerSlashed", {
        proposal_id: faulty_proposal_id,
        reviewer: review.reviewer_pubkey,
      })

// =================================================================
// Human Oracle & External Integration Functions
// =================================================================

// NEW: Allows a user to link their verified BUBIWOT identity to an address on another chain.
// The signature proves ownership of the external address.
FUNCTION link_external_address(chain_id: ChainID, external_address: Address, signature: Bytes):
  // Pre-conditions
  user_pubkey = sender
  user_account = STATE.accounts.get(user_pubkey)
  ASSERT user_account is not None and user_account.is_human_verified, "User must be a verified human to link an address"
  
  // Verify that the sender actually owns the external address.
  // This would involve a chain-specific signature verification (e.g., EIP-712).
  ASSERT verify_external_signature(chain_id, external_address, user_pubkey, signature) is True
  
  // Store the primary link
  user_links = STATE.external_links.get(user_pubkey) or Map()
  user_links.set(chain_id, external_address)
  STATE.external_links.set(user_pubkey, user_links)

  // Store the reverse link for efficient queries
  chain_links = STATE.reverse_external_links.get(chain_id) or Map()
  chain_links.set(external_address, user_pubkey)
  STATE.reverse_external_links.set(chain_id, chain_links)
  
  EMIT Event("ExternalAddressLinked", { owner: user_pubkey, chain: chain_id, address: external_address })

// NEW: PUBLIC query function for external dApps (via IBC/bridge) to check for humanity.
// The fee is collected by the relayer service before this query is called.
QUERY is_human(chain_id: ChainID, external_address: Address, consumer_address: Address):
  // Access Control: Ensure the caller is an authorized oracle consumer.
  consumer = STATE.oracle_consumers.get(chain_id)?.get(consumer_address)
  ASSERT consumer is not None and consumer.is_active, "Not an authorized oracle consumer"
  
  // Perform the efficient lookup
  pubkey = STATE.reverse_external_links.get(chain_id)?.get(external_address)
  if pubkey is None:
    RETURN False
    
  account = STATE.accounts.get(pubkey)
  RETURN account.is_human_verified


// =================================================================
// Treasury Auction Functions
// =================================================================

// INTERNAL function called by the bridge service to credit foreign assets.
// RENAMED and UPDATED: Now credits the main treasury from any source (e.g., oracle fees).
FUNCTION _credit_treasury(asset_denom: String, amount: Uint, source_tx_hash: Bytes):
  // Access control: only a trusted relayer/bridge entity can call this.
  ASSERT is_caller_bridge_relayer(sender)

  current_balance = STATE.treasury_assets.get(asset_denom) or 0
  STATE.treasury_assets.set(asset_denom, current_balance + amount)
  EMIT Event("TreasuryCredited", { asset: asset_denom, amount: amount, source_tx: source_tx_hash })


// Anyone can kick off a new auction if the auction period has passed.
FUNCTION start_auction():
  // Pre-conditions
  ASSERT current_block > STATE.last_auction_start_block + STATE.config.auction_period_blocks, "Auction period not over"
  bubi_to_auction = STATE.accumulated_bubi_for_auction
  ASSERT bubi_to_auction > 0, "No BUBI fees to auction"

  // Reset accumulator and update timer
  STATE.accumulated_bubi_for_auction = 0
  STATE.last_auction_start_block = current_block

  // Create and store the new auction
  auction_id = generate_new_auction_id()
  auction = TreasuryAuction {
    id: auction_id,
    bubi_amount: bubi_to_auction,
    end_block: current_block + STATE.config.proposal_voting_period_blocks, // Re-use voting period for auction duration
    status: "OPEN",
  }
  STATE.auctions.set(auction_id, auction)
  EMIT Event("AuctionStarted", { id: auction_id, bubi_amount: bubi_to_auction })

// A user places a bid on an open auction.
FUNCTION place_bid(auction_id, max_price_btc_per_bubi: Decimal, total_btc_to_spend: Uint, btc_lock_tx_proof: Bytes):
  // Pre-conditions
  auction = STATE.auctions.get(auction_id)
  ASSERT auction is not None and auction.status == "OPEN", "Auction not open"
  ASSERT current_block < auction.end_block, "Auction has ended"

  // TODO: Verify the btc_lock_tx_proof to ensure the BTC is actually held in escrow by the TSS vault.

  // Store the bid
  bid = Bid {
    bidder_pubkey: sender,
    max_price_btc_per_bubi: max_price_btc_per_bubi,
    total_btc_to_spend: total_btc_to_spend,
    btc_lock_tx_proof: btc_lock_tx_proof,
  }
  bids = STATE.bids.get(auction_id) or []
  bids.append(bid)
  STATE.bids.set(auction_id, bids)
  EMIT Event("BidPlaced", { auction_id: auction_id, bidder: sender })

// After an auction ends, anyone can trigger settlement.
FUNCTION settle_auction(auction_id):
  // Pre-conditions
  auction = STATE.auctions.get(auction_id)
  ASSERT auction is not None and auction.status == "OPEN", "Auction not open for settlement"
  ASSERT current_block >= auction.end_block, "Auction has not ended yet"

  // --- Batch Auction Settlement Logic (Uniform Price) ---
  bids = STATE.bids.get(auction_id) or []
  // Sort bids from highest price to lowest
  sorted_bids = bids.sort(by="max_price_btc_per_bubi", order="desc")
  
  bubi_to_sell = auction.bubi_amount
  clearing_price = 0
  total_btc_proceeds = 0
  
  // Step 1: Find the clearing price. This is the price of the last bid that can be
  // at least partially filled to sell all the BUBI.
  bubi_demand_so_far = 0
  winning_bids = []
  losing_bids = []

  for bid in sorted_bids:
    if bubi_demand_so_far < bubi_to_sell:
      clearing_price = bid.max_price_btc_per_bubi
      // We calculate demand at this bid's price just to see if the auction clears.
      bubi_demanded_at_this_price = bid.total_btc_to_spend / bid.max_price_btc_per_bubi
      bubi_demand_so_far += bubi_demanded_at_this_price
      winning_bids.append(bid)
    else:
      losing_bids.append(bid)
  
  // If auction failed to clear (not enough demand), handle it.
  ASSERT bubi_demand_so_far >= bubi_to_sell, "Auction failed to clear due to insufficient demand"

  // Step 2: Settle all winning bids at the single clearing price.
  bubi_left_to_distribute = bubi_to_sell
  for bid in winning_bids:
      // At the uniform clearing price, how much BUBI can the bidder's locked BTC buy?
      bubi_can_afford = bid.total_btc_to_spend / clearing_price
      
      bubi_to_award = 0
      if bubi_can_afford < bubi_left_to_distribute:
        // Bidder gets all the BUBI they can afford at the clearing price.
        bubi_to_award = bubi_can_afford
      else:
        // This bidder is the last (or only) one, getting a full or partial fill of what's left.
        bubi_to_award = bubi_left_to_distribute
      
      if bubi_to_award <= 0: continue

      actual_btc_to_pay = bubi_to_award * clearing_price
      total_btc_proceeds += actual_btc_to_pay
      bubi_left_to_distribute -= bubi_to_award
      
      // Send BUBI to the winner
      winner_account = STATE.accounts.get(bid.bidder_pubkey)
      winner_account.bubi_balance += bubi_to_award
      STATE.accounts.set(bid.bidder_pubkey, winner_account)
      
      // Emit event for the TSS service to handle BTC movement
      EMIT Event("BidWon", {
          auction_id: auction_id,
          bidder: bid.bidder_pubkey,
          btc_to_protocol: actual_btc_to_pay,
          // The refund is the difference between what they locked and what they paid.
          btc_to_refund: bid.total_btc_to_spend - actual_btc_to_pay
      })

  // Signal TSS to refund all losing bids
  for bid in losing_bids:
      EMIT Event("BidLost", { auction_id: auction_id, bidder: bid.bidder_pubkey })

  // Update auction state
  auction.status = "SETTLED"
  auction.clearing_price_btc_per_bubi = Some(clearing_price)
  auction.total_btc_proceeds = Some(total_btc_proceeds)
  STATE.auctions.set(auction_id, auction)

  // This signals the protocol that new BTC is available for distribution
  EMIT Event("AuctionSettled", { id: auction_id, proceeds_btc: total_btc_proceeds })
  
  // Add auction proceeds to the main treasury
  current_treasury_btc = STATE.treasury_assets.get("btc") or 0
  STATE.treasury_assets.set("btc", current_treasury_btc + total_btc_proceeds)
  
  // Allocate all funds currently in the treasury
  _allocate_treasury_funds()

// NEW: INTERNAL function to allocate all assets in the treasury to the SWF and staker rewards pool.
FUNCTION _allocate_treasury_funds():
  split = STATE.config.treasury_revenue_split
  
  for asset, amount in STATE.treasury_assets.items():
    if amount == 0: continue
    
    // Calculate split
    to_swf = amount * split.to_swf
    to_rewards = amount - to_swf // Remainder to rewards to avoid dust
    
    // Add to SWF
    current_swf_balance = STATE.swf_assets.get(asset) or 0
    STATE.swf_assets.set(asset, current_swf_balance + to_swf)
    
    // Add to distributable rewards pool
    current_reward_balance = STATE.distributable_rewards.get(asset) or 0
    STATE.distributable_rewards.set(asset, current_reward_balance + to_rewards)
    
    EMIT Event("TreasuryAllocated", { asset: asset, to_swf: to_swf, to_rewards: to_rewards })

  // Clear the treasury now that it's been allocated
  STATE.treasury_assets = Map()
