BuildSubmission: {
  builder_pubkey: PublicKey,
  build_hash: Bytes,
  submission_block: Uint,
}

AsynchronousRecoveryRequest: {
  target_account_pubkey: PublicKey,
  recovery_pubkey: PublicKey,
  contributed_shares: Map<PublicKey, Bytes>,
  expiry_block: Uint,
  deposit: Option<Coin>,
}

EMIT Event("SuccessionAssetTransferTriggered", {
    deceased_owner: target_account_pubkey,
    heir_owner: new_owner_pubkey
})

FUNCTION initiate_asynchronous_recovery(target_account_pubkey: PublicKey, recovery_pubkey: PublicKey, deposit: Option<Coin>):
  initiator_pubkey = sender
  ASSERT STATE.accounts.get(target_account_pubkey) is not None, "Target account does not exist"
  ASSERT STATE.pending_async_recoveries.get(target_account_pubkey) is None, "Recovery process already initiated for this account"

  if deposit.is_some():
    initiator_account = STATE.accounts.get(initiator_pubkey)
    ASSERT initiator_account is not None, "Initiator account not found"
    ASSERT initiator_account.bubi_balance >= deposit.amount, "Initiator has insufficient funds for deposit"
    initiator_account.bubi_balance -= deposit.amount
    STATE.accounts.set(initiator_pubkey, initiator_account)

  request = AsynchronousRecoveryRequest {
    target_account_pubkey: target_account_pubkey,
    recovery_pubkey: recovery_pubkey,
    contributed_shares: Map(),
    expiry_block: current_block + STATE.config.async_recovery_period_blocks,
    deposit: deposit,
  }
  STATE.pending_async_recoveries.set(target_account_pubkey, request)

  EMIT Event("AsynchronousRecoveryInitiated", { 
    target: target_account_pubkey, 
    recovery_pubkey: recovery_pubkey,
    expiry: request.expiry_block
  })

FUNCTION contribute_recovery_share(target_account_pubkey: PublicKey, encrypted_share: Bytes):
  guardian_pubkey = sender
  request = STATE.pending_async_recoveries.get(target_account_pubkey)
  ASSERT request is not None, "No active recovery process for this account" 