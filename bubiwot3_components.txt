# BUBIWOT v3 System Architecture & Components

This document details the concrete components required to build the BUBIWOT sovereign digital commons. The system is best understood as a self-hosting stack where the protocol's users govern its evolution. The key components include the BUBIWOT Appchain, a deeply integrated smart contract layer for governance, a multi-layered P2P client, and expanded validator services that host the protocol's own codebase.

---

### Component 1: The Core Blockchain (the BUBIWOT "Appchain")

The sovereign, application-specific blockchain that serves as the ultimate settlement layer and source of truth for the entire ecosystem.

*   **Technology**: Cosmos SDK, CometBFT, Ignite CLI. Secured by Bitcoin via the Babylon protocol.
*   **Language**: Go.
*   **Core Modules**:
    *   Standard Cosmos Modules: `x/auth`, `x/bank`, `x/gov`.
    *   `x/wasm`: The CosmWasm module, which hosts all core logic and governance.
    *   Encrypted Mempool Module: A module to support threshold-encrypted transactions, mitigating validator front-running (MEV) and content-based censorship.
    *   `x/ibc-go`: For communication with the Babylon chain.
    *   Babylon Consumer Module: To inherit Bitcoin-grade security.
*   **Purpose & Responsibilities**:
    *   To provide a permanent, immutable ledger for accounts, balances, and identity attestations.
    *   To serve as the execution environment for the governance, identity, and economic smart contracts.
    *   To secure the state transitions that result from community governance votes (e.g., updating the on-chain client registry).
    *   To expose endpoints (RPC, gRPC) for clients to interact with the chain's state and submit transactions.

---

### Component 2: The Smart Contract Layer (The On-Chain "Constitution")

This is the logical core of the BUBIWOT commons, containing not just application logic but the rules for its own evolution.

*   **Technology**: CosmWasm, with integrated zk-SNARK verifiers.
*   **Language**: Rust.
*   **Key Contracts / Modules**:
    *   **Account Hub (`bubi-hub`)**: Manages user accounts, BUBI token balances, and the core components of their digital identity. Its primary responsibilities are:
        *   Storing **verifiable evidence of personhood** rather than a simple status flag. This includes maintaining a list of hardware-bound `DeviceRecord`s and a `PeerVerificationRecord` upon successful social attestation. This allows consumers of the oracle to apply their own logic to determine trust, rather than relying on a single protocol-defined state.
        *   Maintaining a rich vector of **atomic, machine-verifiable metrics** for each user, representing their on-chain activity, reputation, security posture, and economic standing. These metrics are committed to a per-account Merkle tree (`metrics_root`), enabling users to generate privacy-preserving ZK-proofs about specific facts (e.g., "my guardian count is >= 5 and I have never been slashed") without revealing their entire identity profile.
        *   Managing reputation in distinct buckets (e.g., `developer_reputation`, `guardian_reputation`) that are updated based on on-chain actions.
        *   Managing the link between a user's BUBIWOT public key and their wallets on other blockchains (`external_links`), which is essential for the Humanity Oracle.
    *   **Governance Module**: The heart of the decentralized organization.
        *   **Proposal System**: Manages community proposals, including `CodeChange` proposals for the core software, `RegistryUpdate` proposals for infrastructure pointers, `RegisterApplication` proposals for the Sovereign App Store, `BugReport` proposals that trigger the bug bounty system, **`AuthorizeOracleConsumer` proposals to whitelist external protocols that can consume the rich identity proofs from the Humanity Oracle**, and strategic proposals for the Sovereign Wealth Fund like `ProposeAlliance` and `VoteInExternalDAO`.
        *   **Stake-Gated Submissions**: Requires developers to post a `proposal_bond` in BUBI to submit a proposal, which can be slashed if the proposal is found to be malicious.
        *   **ZK-Voting**: Implements a zk-SNARK verifier to allow verified humans to vote privately. The contract checks the proof and nullifier, tallying votes without ever linking them to a public key.
    *   **On-Chain Registry (`resolver-contract`)**: An ENS-like contract that maps human-readable names to infrastructure endpoints (e.g., `client.bubi` -> `bubi-storage://Qm...`). This is expanded to function as a "Sovereign App Store," where passed `RegisterApplication` proposals create entries for community-vetted third-party apps. To enhance censorship resistance, it supports multiple, redundant pointers for critical infrastructure. For example, a single name can resolve to multiple, redundant content-addressed hashes, allowing the client to fetch assets from whichever network is available. Critically, only the Governance Module has the authority to update these records, making infrastructure changes and application listings subject to a community vote.
    *   **Treasury, Oracle & Economy Module**:
        *   **Staked Code Reviews**: Allows users to stake BUBI to attest to the quality and safety of a pending code proposal. Rewards and slashing are determined objectively based on the outcome of governance votes, especially in response to `BugReport` proposals.
        *   **Bounty System**: Manages community-funded bounties for new features, automatically paying out to the developer whose approved `CodeChange` proposal fulfills the bounty.
        *   **Revenue, Treasury, SWF & UBI Stability**: This module houses the protocol's complete, end-to-end economic engine. It programmatically captures revenue from multiple streams (B2B oracle fees, on-chain auctions of network fees). **The oracle revenue stream is tiered, supporting premium fees for high-value, complex ZK-proof verifications over a user's atomic metrics.** All revenue flows into a central `treasury_assets` map. Periodically, these funds are allocated based on a governable `treasury_revenue_split` policy. A portion is sent to a `distributable_rewards` pool for BUBI stakers, and the remainder is transferred to the `swf_assets` map, capitalizing the protocol's Sovereign Wealth Fund. This module also manages the governance proposals (`ExecuteSWFStrategy`, `ProposeAlliance`) that allow BUBI holders to deploy SWF capital into strategic investments, form alliances, and participate in meta-governance on other blockchains. It also enforces the dynamic UBI claim rate to ensure a stable emission schedule.

---

### Component 3: The In-Browser P2P Client (The Sovereign User Portal)

The user-facing application, architected as a powerful three-layered light client that orchestrates interactions across different P2P networks for maximum security and efficiency. It is designed to provide a simple, sovereign user experience while managing significant cryptographic complexity under the hood.

*   **Technology**: TypeScript, Next.js, CosmJS, js-libp2p, nostr-tools.
*   **Language**: TypeScript / JavaScript.
*   **Key Design Principles & Features**:
    *   **Seamless Key Management & Device Attestation**: The client abstracts away the complexity of managing multiple keys. **During the initial onboarding, it interacts with the device's native hardware security module (TPM, Secure Enclave) to generate a unique, non-exportable signature, creating a verifiable device fingerprint that is registered on-chain.** For instance, it manages the user's primary account key and their dedicated "guardian key" as part of a single, unified session. This allows for advanced security features like cryptographic isolation for guardian duties without burdening the user.
    *   **Guided Succession Planning**: The client features a dedicated, easy-to-understand interface for setting up on-chain succession policies. It guides the user through selecting heirs from their trusted contacts, setting an inactivity period, and understanding the security implications of the process. This transforms the BUBIWOT account into a durable, inheritable digital identity.
    *   **Mobile-First Dashboard & Core UI**: The client's interface is designed as a responsive, mobile-first single-page application. The core view is a dashboard presenting key information via clear, interactive "cards": a **Wallet Card** for balances and transactions; a **Recovery Health Card** with a visual score and a one-tap link to manage guardians; a **Social Feed Card** for notifications and content; and an **App Store Card** to browse and launch vetted dApps. This component-based design ensures a clean, uncluttered user experience on any device.
    *   **Personal Data Vault Management**: The client serves as the user's primary interface for their encrypted, decentralized data vault. It manages the client-side encryption/decryption of data, which is then stored on a decentralized storage network. It also provides a clear interface for managing data permissions, allowing users to grant granular, time-limited, and revocable access to third-party applications via the on-chain `CapabilityGrant` system.
    *   **The Sovereign App Store**: The client includes a dedicated interface to browse and launch third-party applications that are registered on-chain in the `resolver-contract`. This provides users with a safe, curated environment to explore the BUBIWOT ecosystem, knowing that every application has passed a community governance vote and a verifiable build process. This transforms the client from a simple wallet into a trusted window into the broader decentralized web.
    *   **Privacy-Preserving Proof Generation**: The client contains an SDK that allows users to easily generate ZK-proofs of their on-chain attributes (e.g., "I have a reputation score > 500"). This is the core engine for the protocol's **ZK-OAuth** functionality. When an external dApp sends a `CapabilityRequest` via Nostr, the client parses it, generates the required proof client-side, and orchestrates the response, ensuring user data is never revealed.
    *   **Device Mesh for Session Redundancy**: To improve fault tolerance, the client supports an optional multi-device mesh. Users can designate companion devices (e.g., laptop and phone), each holding limited-privilege session keys. The client facilitates an ephemeral co-signing protocol between these devices, allowing a lost session to be regenerated on a new device without triggering a full social recovery.
    *   **Hard-coded Bootstrapping & Quorum Verification**: To mitigate attacks on the very first connection, the client is distributed with a hard-coded list of public keys belonging to core community members or protocol founders. On first run, it fetches the `resolver-contract` address and the latest client hash from multiple Nostr relays signed by these keys. The client only proceeds if a quorum (e.g., 3 of 5) of these trusted sources agree on the correct addresses and hashes, preventing initial redirection attacks.
    *   **Decentralized Entry Points**: To avoid reliance on censorable DNS, the client's entry points should be decentralized. The protocol can recommend using gateways for decentralized naming systems like ENS (e.g., `client.bubi.eth.limo`) or Handshake (HNS). The canonical content hash for the client can also be distributed via high-follower Nostr accounts or other social channels as a final backstop.
    *   **Privacy-Preserving RPC**: For users in sensitive environments, the client should support routing its RPC requests through privacy-preserving networks like a mixnet (e.g., Nym) or a dVPN. This obscures the user's IP address from the RPC provider, preventing IP-based blocking or surveillance.
    *   **Guided Policy & Guardian Management**: The client features a full-page, mobile-friendly interface for managing guardians, ranked by relevant data to encourage mutual attestation. This interface visualizes the user's web of trust, showing guardian avatars, their on-chain status (liveness), and reputation. The process of adding a guardian is streamlined into a simple request flow, similar to a social media friend request. It also provides wizard-driven tools that abstract granular policy parameters into intuitive "security levels," (e.g., "Basic," "Enhanced," "Maximum") guiding users toward optimal settings.
    *   **Proactive Security Nudges**: The client provides a clear **"Recovery Health" score that is computed client-side** based on canonical on-chain metrics like guardian liveness and reputation. It proactively nudges users to perform periodic guardian reviews and can offer intelligent suggestions for new guardians by analyzing the user's social graph, turning security maintenance into an engaging process. These nudges appear as non-intrusive notifications within the client dashboard (e.g., "Your guardian liveness ratio has dropped below 80%. Consider reaching out to them.") to guide users in maintaining a robust recovery network without needing to be security experts.
    *   **Policy Simulation & Visualization**: To empower users to make informed security decisions, the client will include tools to simulate and visualize the effects of their on-chain `AccountPolicy` and the state of their atomic metrics. This could show them their current recovery resilience against various threat models, suggest policy adjustments based on their social graph, and make the power of composable, user-defined trust rules accessible.
*   **Client-side Architecture**:
    *   **Layer 1: Appchain Service (CosmJS - "The Truth Layer")**: Manages all communication with the BUBIWOT Appchain. Its roles include: 1) Querying the `resolver-contract` to find the correct, community-approved RPC endpoints. 2) Submitting transactions for staking, claims, and governance votes. 3) Posting `CapabilityGrant` transactions as part of the ZK-OAuth flow.
    *   **Layer 2: Social Service (Nostr - "The Discovery Layer")**: Manages connections to Nostr relays for fast, ephemeral, and decentralized signaling. Its roles include: 1) Publishing and consuming social content. 2) Broadcasting and monitoring guardian liveness heartbeats. 3) Peer discovery for initiating private recovery sessions. **4) Critically, it listens for `CapabilityRequest` events (e.g., `kind: 31111`) from external applications, serving as the decentralized entry point for the entire ZK-OAuth protocol.**
    *   **Layer 3: Private Service (LibP2P - "The Secure Layer")**: Manages direct, secure, end-to-end encrypted browser-to-browser communication channels. Its primary role is to facilitate the exchange of sensitive data like BUSS recovery shares and **to aggregate guardian co-signatures for high-security `CapabilityRequest`s off-chain.**
    *   **Guardian Liveness Service (Light Node)**: For users who act as guardians, the client runs a lightweight background process that functions as a proof-of-liveness light node. It periodically crafts and signs an on-chain "guardian heartbeat" transaction, attesting to the guardian's availability and earning them liveness rewards. This service also monitors other guardians for the user, providing data for the "Recovery Health" score.
*   **Key Services**:
    *   **Threshold Signature Scheme (TSS) Executor Service**: The validator set collectively controls a set of wallets for the protocol (treasury, SWF) on BUBIWOT and external chains like Bitcoin and Ethereum. This service's role is expanded beyond simple payouts. **It is also responsible for managing per-user Sovereign Bitcoin Vaults.** It listens for on-chain events and performs the following actions:
        *   **Vault Creation:** On a `SovereignVaultCreationRequested` event, it performs a Distributed Key Generation (DKG) ceremony to create a new Bitcoin key pair for a specific user and calls `_register_sovereign_btc_vault` to record the new public address on-chain.
        *   **User Transactions:** On a `BtcSpendAuthorized` event, it collectively signs the specific Bitcoin transaction requested by the user and broadcasts it to the Bitcoin network.
        *   **Protocol Transactions:** On a passed `ExecuteSWFStrategy` proposal or `BidWon` event, it uses the TSS protocol to collectively sign the specific, authorized transactions—be it a BTC payout, an asset swap on Uniswap, or a meta-governance vote.
    *   **Cross-Chain Bridge & Oracle Relayer Service**: A service, operated by validators, that serves two primary functions: 1) It monitors designated vaults on external blockchains (e.g., Ethereum, Solana) for strategic deposits and yield farming rewards. When tokens are deposited, this service provides the necessary attestations to the BUBIWOT Appchain's `Treasury Module`. 2) It acts as the response gateway for the ZK-OAuth protocol for cross-chain consumers. While requests are discovered P2P via Nostr, this service can be used by smart contracts on other chains to call `pay_and_post_cr` on their behalf. More importantly, it can deliver the final `ProofBundle` (containing ZK proofs and signatures) back to a calling contract on another chain, completing the cross-chain interaction loop. This service works in tandem with the TSS to secure bridged assets and collected fees.
    *   **Decentralized Code Hosting Service**: A new, critical responsibility. Validators run a client for a decentralized version control system (e.g., Radicle) to "pin" the canonical version of the BUBIWOT source code. They collectively ensure the availability of the codebase that governance has approved.
    *   **Decentralized Storage Pinning Service**: Validators also provide pinning services for the protocol's content-addressed storage network. This service is funded by user-paid fees attached to on-chain content pointers. When a user archives content, a small BUBI fee is escrowed and paid out over time to validators who prove they are storing the data, creating a sustainable market for long-term data persistence.
    *   **Watchtower Service**: Independent, permissionless services that monitor on-chain data to detect and report censorship or other validator misbehavior. To incentivize their crucial role, watchtowers can submit evidence in a `SlashValidator` proposal. If the proposal passes, the watchtower receives a significant portion of the slashed validator's bond as a reward, creating a strong economic incentive for policing the network.
    *   **On-Chain Treasury Auction Service**: Instead of relying on external oracles, the protocol uses a batch auction system to convert accumulated BUBI fees into BTC. The TSS service, operated by validators, plays a crucial role here. It manages a temporary BTC escrow for bidders and executes the final BTC transfers upon auction settlement. This service listens for on-chain auction events (`AuctionSettled`) to know which BTC transactions to sign, creating a fully self-contained economic loop without external price dependencies.
    *   **Verifiable Build Service**: A **permissionless service run by a competitive network of staked "Builders"**. This service is responsible for pulling the latest approved commit hash, running a deterministic build, and submitting the resulting application hash to be validated by governance and recorded in the on-chain registry. Making this process open and competitive, rather than a mandatory validator duty, is critical for ensuring a trust-minimized and censorship-resistant software supply chain.

---

### Component 4: Off-Chain Services (Validator-Operated Infrastructure)

Critical infrastructure run by the BUBIWOT appchain's validators, extending their role from just securing the chain to actively hosting the commons.

*   **Technology**: Go or Rust services running alongside the validator node.
*   **Key Services**:
    *   **Threshold Signature Scheme (TSS) Service**: The validator set collectively controls a Bitcoin treasury wallet to manage rewards and fee distributions, acting on `BtcPayoutRequest` events from the smart contracts.
    *   **Cross-Chain Bridge Service**: A service, operated by validators, that monitors designated vaults on external blockchains (e.g., Ethereum, Solana). When tokens are deposited, this service provides the necessary attestations to the BUBIWOT Appchain, allowing the `Treasury Module` to mint a corresponding claim or credit the assets to the protocol's cross-chain vault. This service works in tandem with the TSS to secure bridged assets.
    *   **Decentralized Code Hosting Service**: A new, critical responsibility. Validators run a client for a decentralized version control system (e.g., Radicle) to "pin" the canonical version of the BUBIWOT source code. They collectively ensure the availability of the codebase that governance has approved.
    *   **Decentralized Storage Pinning Service**: Validators also provide pinning services for the protocol's content-addressed storage network. This service is funded by user-paid fees attached to on-chain content pointers. When a user archives content, a small BUBI fee is escrowed and paid out over time to validators who prove they are storing the data, creating a sustainable market for long-term data persistence.
    *   **Watchtower Service**: Independent, permissionless services that monitor on-chain data to detect and report censorship or other validator misbehavior. To incentivize their crucial role, watchtowers can submit evidence in a `SlashValidator` proposal. If the proposal passes, the watchtower receives a significant portion of the slashed validator's bond as a reward, creating a strong economic incentive for policing the network.
    *   **On-Chain Treasury Auction Service**: Instead of relying on external oracles, the protocol uses a batch auction system to convert accumulated BUBI fees into BTC. The TSS service, operated by validators, plays a crucial role here. It manages a temporary BTC escrow for bidders and executes the final BTC transfers upon auction settlement. This service listens for on-chain auction events (`AuctionSettled`) to know which BTC transactions to sign, creating a fully self-contained economic loop without external price dependencies.
    *   **Verifiable Build Service**: A **permissionless service run by a competitive network of staked "Builders"**. This service is responsible for pulling the latest approved commit hash, running a deterministic build, and submitting the resulting application hash to be validated by governance and recorded in the on-chain registry. Making this process open and competitive, rather than a mandatory validator duty, is critical for ensuring a trust-minimized and censorship-resistant software supply chain.

---

### How The Components Relate: A Code-to-Client Workflow

This workflow illustrates how a code change is proposed and deployed in a fully trust-minimized way:

1.  **Proposal**: A developer with a BUBIWOT account writes new code and pushes it to the P2P git network. They then call the `Governance Module` on-chain, posting a BUBI bond and creating a proposal to update the canonical code to their new commit hash.
2.  **Review & Audit**: Other developers and security auditors review the code. They can use the `Developer Economy Module` to stake BUBI behind their review, signaling their approval or rejection and earning a reward if their assessment aligns with the final vote outcome.
3.  **Vote**: The community of verified humans uses their **P2P Client** to cast private votes. The client generates a ZK-proof locally and submits it to the **Appchain**. The **Governance Module** verifies the proofs and tallies the votes.
4.  **Execution & Hosting**: If the vote passes, the **Governance Module** emits an event. The **Decentralized Code Hosting Service** run by validators sees this event and updates their pinned repository to the new canonical commit hash.
5.  **Build & Deployment**: A decentralized build network builds the new application. The hash of the built application is submitted in a new proposal to update the **On-Chain Registry**.
6.  **Resolution & Loading**: When a user opens their **P2P Client**, it first queries the **On-Chain Registry** to get the latest community-approved content hash, then loads the new application directly from its peers.
