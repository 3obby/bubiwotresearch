ANARKey: A New Approach to (Socially) Recover Keys
Aniket Kate

Pratyay Mukherjee

Hamza Saleem

Purdue University / Supra Research
USA
aniket@purdue.edu

Supra Research, India
pratyay85@gmail.com

Supra Research, USA
h.saleem@supraoracles.com

Pratik Sarkar

Bhaskar Roberts

Supra Research, India
iampratiksarkar@gmail.com

University of California, Berkeley
USA
bhaskarr@berkeley.edu

ABSTRACT
In a social key recovery scheme, users back up their secret keys
(typically using Shamirâ€™s secret sharing) with their social connections, known as a set of guardians. This places a heavy burden
on the guardians, as they must manage their shares both securely
and reliably. Finding and managing such a set of guardians may
not be easy, especially when the consequences of losing a key are
significant.
We take an alternative approach of social recovery within a community, where each member already holds a secret key (with possibly an associated public key) and uses other community members
as their guardians forming a mutual dependency among themselves.
Potentially, each member acts as a guardian for upto (ğ‘› âˆ’ 1) other
community members. Therefore, in this setting, using standard
Shamirâ€™s sharing leads to a linear (ğ‘‚ (ğ‘›)) blow-up in the internal
secret storage of the guardian for each key recovery. Our solution
avoids this linear blowup in internal secret storage by relying on a
novel secret-sharing scheme, leveraging the fact that each member
already manages a secret key. In fact, our scheme does not require
guardians to store anything beyond their own secret keys.
We propose the first formal definition of a social key recovery
scheme for general access structures in the community setting. We
prove that our scheme is secure against any malicious and adaptive
adversary that may corrupt up to ğ‘¡ parties. As a main technical
tool, we use a new notion of secret sharing, that enables (ğ‘¡ + 1)
out of ğ‘› sharing of a secret even when the shares are generated
independently â€“ we formalize this as bottom-up secret sharing
(BUSS), which may be of independent interest.
Finally, we provide an implementation benchmarking varying
the number of guardians both in a regional, and geo-distributed
setting. For instance, for 8 guardians, our backup protocol takes
around 146-149 ms in a geo-distributed WAN setting, and 4.9-5.9
ms in the LAN setting; for recovery protocol, the timings are approximately the same for the WAN setting (as network latency
dominates), and 1.2-1.4 ms for the LAN setting.

1

INTRODUCTION

Cryptography plays a crucial role in securing and authenticating
data in the digital space by providing mathematically proven guarantees. However, virtually all such guarantees crucially rely on
keeping the underlying secret key secure and available, both at the
Bhaskar Roberts worked on this project primarily during a summer internship at Supra
Research.

same time. In the blockchain space, due to its fundamental reliance
on cryptography, creating secure and reliable (that is available when
needed) wallet services, for storing keys, has garnered substantial
attention [10, 17] in the past few years.
Storing secret keys in wallets securely and reliably turns out
to be remarkably challenging. Among many a primary challenge
is, unlike passwords, keys can not be reset easily. For example, if
certain funds are â€œlockedâ€ with respect to a particular public-key,
such that a transaction requires a signature using the corresponding secret-key, then those funds are lost forever if the secret key
cannot be recovered. It is estimated that USD 140 billions worth of
BTC is unrecoverable due to lost secret keys [26]! Therefore, many
existing wallets support a backup option, either via mnemonic
pass phrases [14], which one may write down in a secure place,
or splitting the key [11, 19] using simple secret sharing (such as
Shamirâ€™s [23]) and storing the shares in different devices â€“ each
share must be secured with another authentication mechanism,
such as passwords. But even for those solutions (also called cold [12]
or hardware wallets [29]) incidental memory erasure or losing passwords (or a combination) 1 may happen realistically invoking a loss
of funds. In fact, in scenarios involving permanent disappearance,
such as the death or disability of the key-owner, a similar loss of
funds can take place.
Many of these issues are mitigated in social recovery solutions,
which, as laid out by Buterin [8], carry substantial benefits in terms
of usability and reliability without compromising security. In a
social recovery scheme, a key-owner uses parties from her social
circle, also known as guardians, to back up her secret key. A typical
recovery access structure can be (ğ‘¡ + 1)-out-of-ğ‘› threshold, where ğ‘›
guardians are used for backup and any (ğ‘¡ + 1) of them are required
to recover the key. This setting will be secure as long as at most ğ‘¡
of the shares are captured, by collusion or otherwise. Importantly,
in the event of a permanent disappearance of the key-owner, e.g.
demise, the legitimate nominee can coordinate with any (ğ‘¡ + 1)
guardians to recover the secret key and thus inherit any asset locked
with the key.
However, the security and reliability aspects of the social recovery approach crucially relies on the guardians. An ideal guardian
should be technologically adept, trustworthy, and reliable. Finding

1 In [8], a real-world example was given for a Bitcoin developer Stefan Thomas, who had

three backups entities â€“ an encrypted USB stick, a Dropbox account and a Virtualbox
virtual machine. However, he accidentally erased two of them and forgot the password
of the third, forever losing access to 7,000 BTC (worth $125, 000 at the time).

Aniket Kate, Pratyay Mukherjee, Hamza Saleem, Pratik Sarkar, and Bhaskar Roberts

a set of guardians all of whom posses these attributes to a reasonable degree may not be easy. Importantly, since the guardians do
not have any stake (barring just helping the key owner) with the
existing approaches, it may be too optimistic to assume that they
would store the shares both securely and reliably.
Motivated by this, we put forward a new community-based model
for social recovery. Our model considers a community of secret-key
holders (e.g., users of cryptocurrency), such that everyone can use
(a subset of) the other community members as their guardians. In
return, they are also expected to serve as guardians for other parties.
This creates an ecosystem of mutual dependence, in that there is a
clear motivation for each member to store the shares of other key
owners securely and reliably, with the hope that the other members
would also return the favor.
Using a simple (ğ‘¡ + 1)-out-ğ‘› secret sharing in this model, however, incurs new issues, as we elaborate next: let skğ‘– is party ğ‘ƒğ‘– â€™s
secret key, which is a 256-bit string. A secret sharing of skğ‘– would
generate ğ‘› shares ğœğ‘–,1, ğœğ‘–,2, . . . ğœğ‘–,ğ‘› , where ğœğ‘–,ğ‘— belongs to guardian
ğ‘ƒ ğ‘— â€“ each ğœğ‘–,ğ‘— is also a 256 bit string. Now, in the community setting,
everyone would potentially use other members as guardians, and
hence it is expected that party ğ‘ƒ ğ‘— may have to serve as a guardian
for ğ‘š different key-owners. In that scenario, ğ‘ƒ ğ‘— has to manage ğ‘š
different shares securely and reliably. The requirement of securely
and reliably many shares (scales with ğ‘‚ (ğ‘š)) becomes challenging
for the members, and even worse, this may end up discouraging
users from joining the community.
To resolve this issue we propose a new solution, in that, parties
do not need to store any additional data beyond their own secret
key securely and reliably. Our main idea is to leverage the fact that
each user already maintains a secret-key, and the shares would be
derived from that without hurting security. In fact, our protocol is
quite general and works beyond the community setting: as long as
each guardian can manage a single secret key, there is no need to
store any additional information, regardless of the number of key
owner the guardian supports.

1.1

The scheme supports every party to back up their respective keys with (a subset of) everyone else, without needing
to store anything apart from their own secret key â€“ this
establishes an ecosystem of mutual dependence without
additional overhead. Our protocol is secure (with abort)
against any malicious and adaptive corruption up to ğ‘¡ parties. We also emphasize that both our backup and recovery protocols require only a single round trip interaction
in a star network, with the key-owner in the center, and
guardians sending a single message, without requiring any
synchronization among themselves â€“ in fact, the guardians
do not require to know each other.2
â€¢ The main technical tool, we rely upon, is a new type of
secret sharing scheme, which supports independent shares
for a (ğ‘¡ + 1)-out-of-ğ‘› threshold access structure â€“ given
a secret, and (ğ‘› âˆ’ 1)-many independently chosen shares,
one can produce a (set of) public values, such that during
reconstruction, any (ğ‘¡ + 1) of the shares and the public
values can be combined to reconstruct the secret. This type
of secret sharing has been used recently by Baird et al. [3]
to design multiverse threshold signatures. In this paper we
formalize this as bottom-up secret sharing (BUSS) with an
adaptive simulation security definition â€“ this may be of
independent interest.
â€¢ To demonstrate practicality we perform extensive benchmarking, varying the tools (such as the types of elliptic
curves and hash functions) and the number of guardians
both in a regional, and geo-distributed setting. For instance,
with standard hash functions, for 8 guardians, our backup
protocol takes around 146-149 ms in a geo-distributed WAN
setting (with a network delay of 138 ms), and 4.9-5.9 ms
in the intra-regional LAN setting; for recovery protocol,
the timings are approximately the same for WAN setting
(as communication latency dominates), and 1.2-1.4 ms for
the LAN setting. We also provide more optimized numbers with multi-threading that enhances the performances
significantly (see Section 7 for details).

Our Contribution

In short, our contributions are:
â€¢ We introduce the concept of community-based social recovery. We formalize the correctness and security definitions of
community-based social key recovery schemes in a standalone simulation-based framework [9, 16]. Intuitively, our
definition ensures that no computationally bounded adversary, which corrupts parties (maliciously and adaptively)
satisfying some access structure is able to distinguish between a real world where the actual protocol is run and
an ideal world, where the honest partyâ€™s responses are
computed without their secret inputs. To the best of our
knowledge, this is the first formalization of any social key
recovery scheme.
â€¢ We design a simple protocol for community-based social
key recovery. Each ownerâ€™s key can be backed up with a
subset of the rest of the community members, denoted as
guardians. The guardians do not have to store anything
in addition to their own key. For recovery, any (ğ‘¡ + 1)
guardians must help correctly for a pre-defined threshold ğ‘¡.

Additionally, we discuss a few extensions of our key recovery
scheme to accommodate settings where a guardian may update
their secret key, or maintain a separate â€œguardian-keyâ€ in addition
to its signing key. We further demonstrate that our scheme can
be made to work on top of most cold wallets, such as Ledger [15],
Trezor [29], where the guardians store their secret keys in the cold
wallet and use that only for producing deterministic signatures.

1.2

Technical Overview

Let us first describe our community setting, in that there are ğ‘
parties ğ‘ƒ1, . . . , ğ‘ƒ ğ‘ pairwise connected via secure and authenticated
channels. Also we assume a reliable public storage, e.g. a bulletin
board. We assume that each party ğ‘ƒğ‘– holds a key skğ‘– generated by
executing a key-generation algorithm (skğ‘– , pkğ‘– ) â† KeyGen(1ğœ† ),
2 As elaborated by Buterin [8], guardians not knowing each other intuitively reduces

the possibility of collusion. In our community setting consisting of ğ‘ members, a key
owner can use any subset (say, of size ğ‘› ) of the members as her guardians. So there

are ğ‘
ğ‘› many such possibilities, which means guessing the set of guardians has a low
probability of success for adequately chosen ğ‘› , for instance, ğ‘› = ğ‘ /2

ANARKey: A New Approach to (Socially) Recover Keys

ğœ‘1

3. ğœ‘

(pk1 , pk2 , pk3 , pk4 )

(pk1 , pk2 , pk3 , pk4 )

Bulletin Board

Bulletin Board

1

3. ğœ‘

1. REQ

1. REQ

ğ‘ƒ1 (sk1 )

ğ‘ƒ2 (sk2 )

ğ‘ƒ2 (sk2 )

ğ‘ƒ1

2. ğœ1,2

2. ğœ1,2

1. R
E

2. ğœ1,3

1

Q

2. ğœ1,3

1. REQ

1. REQ

2. ğœ

4. Recon(pk1, ğœ‘ 1, ğœ1,2, ğœ1,3 ) â†’ sk1 /âŠ¥

1,4

ğ‘ƒ3 (sk3 )

ğ‘ƒ4 (sk4 )

(a) Party ğ‘ƒ 1 â€™s key backup with ğ‘ƒ 2 , ğ‘ƒ 3 , and ğ‘ƒ 4

ğ‘ƒ3 (sk3 )
(b) Party ğ‘ƒ 1 â€™s key recovery with ğ‘ƒ 2 and ğ‘ƒ 3

Figure 1: Workflow of our social key recovery scheme (ğ‘› = 4, ğ‘¡ = 1) where ğµ = {2, 3, 4} and ğ‘… = {2, 3}. We denote the shares
as {ğœ1,ğ‘— } ğ‘— âˆˆ {2,3,4} and the public point as ğœ‘ 1 . Algorithm Recon reconstructs the secret sk1 using the public point ğœ‘ 1 and shares
(ğœ1,2, ğœ1,3 ) and matches it with pk1 .
where ğœ† is a security parameter.3 The public keys are published
on the bulletin board in the beginning and serve as identities. For
simplicity we use integers ğ‘– âˆˆ [ğ‘ ] to represent party ğ‘ƒğ‘– â€™s identity.
Also, fix a threshold ğ‘¡ (as a parameter) and assume that every party
uses exactly ğ‘› âˆ’ 1 > ğ‘¡ (ğ‘› < ğ‘ ) other parties as guardians â€“ our protocol also works if each key-owner chooses a different ğ‘› satisfying
ğ‘› âˆ’ 1 > ğ‘¡.
Now, when ğ‘ƒğ‘– wishes to backup her secret key skğ‘– (for which a
public key pkğ‘– is publicly known), she selects a set ğµ âŠ† [ğ‘ ] \ {ğ‘–}
of ğ‘› âˆ’ 1 guardians {ğ‘ƒ ğ‘— } ğ‘— âˆˆğµ . As mentioned earlier, a simple (ğ‘¡ + 1)out-of-ğ‘› secret sharing using a ğ‘¡-degree polynomial would yield
to a share ğœğ‘–,ğ‘— (for guardian ğ‘ƒ ğ‘— ), which is uncorrelated with ğ‘ƒ ğ‘— â€™s
own secret key sk ğ‘— . Our goal is to use sk ğ‘— to derive ğœğ‘–,ğ‘— for any
ğ‘– instead. At first glance, this looks hard, because deriving each
ğœğ‘–,ğ‘— from independently sampled sk ğ‘— â€™s would lead to independent
shares ğœğ‘–,ğ‘— â€™s â€“ in general this leads to a ğ‘›-out-of-ğ‘› (or additive)
secret sharing. However, here we use a technique recently used
by Baird et al. [3]. The idea is to first derive {ğœğ‘–,ğ‘— } ğ‘— âˆˆ [ğ‘›âˆ’1] independently (deterministically using corresponding sk ğ‘— ), which together
with the key-ownerâ€™s secret skğ‘– defines an (ğ‘› âˆ’ 1)-degree polynomial. Nevertheless, making another (ğ‘› âˆ’ ğ‘¡ âˆ’ 1) points on the
polynomial public reduces the â€œeffective thresholdâ€ of the system to
(ğ‘¡ + 1). These additional points would be derived via interpolation
by the key-owner ğ‘ƒğ‘– herself, once she gets back all {ğœğ‘–,ğ‘— } ğ‘— âˆˆğµ , and
then those points will be made public. 4 A couple of issues still
3 For example, this can be a key generation algorithm of BLS signature, where pk = ğ‘”sk

for a group generator ğ‘”. Also we note that, our scheme works even if parties use
different KeyGen, as long as the key pair satisfies certain basic conditions, as described
in Section 6. For simplicity, in this paper, we consider that every party executes the
same KeyGen.
4We observe that for each backup session a fresh set of (ğ‘› âˆ’ ğ‘¡ âˆ’ 1) public points are
generated. Storing all of these on the blockchain would require spending substantial

remain: (i) a guardian ğ‘ƒ ğ‘— must ensure that ğœğ‘–,ğ‘— does not leak any
information about sk ğ‘— ; (ii) the (ğ‘› âˆ’ ğ‘¡ âˆ’ 1) public points must be
computed on inputs that are different from any input corresponding
to ğœğ‘–,ğ‘— . The first issue is fixed by using the following derivation
ğœğ‘–,ğ‘— := H(ğ‘–, sk ğ‘— ) (alternatively ğœğ‘–,ğ‘— := H(pkğ‘– , sk ğ‘— )) â€“ assuming H is
a random oracle this gives no information about sk ğ‘— , as long as sk ğ‘—
is hard to compute given pkğ‘– (for example, the public key in BLS
signature [7] and ECDSA signature this is true due to the hardness
of computing discrete log). The second issue is resolved by using
negative evaluation points âˆ’1, âˆ’2, . . . , âˆ’(ğ‘› âˆ’ ğ‘¡ âˆ’ 1), akin to Baird et
al. [3]. The overall backup protocol can be summarized as follows:
â€¢ The key-owner ğ‘ƒğ‘– chooses a set ğµ âŠ† [ğ‘ ] \ {ğ‘–} and reaches
out to the guardians ğ‘ƒ ğ‘— for all ğ‘— âˆˆ ğµ.
â€¢ Each guardian ğ‘ƒ ğ‘— , on receiving the request, computes ğœğ‘–,ğ‘— :=
H(ğ‘–, sk ğ‘— ) and sends that back to ğ‘ƒğ‘– .
â€¢ ğ‘ƒğ‘– , on receiving {ğœğ‘–,ğ‘— } ğ‘— âˆˆğµ , computes a (ğ‘› âˆ’ 1)-degree polynomial ğ‘“ğ‘– (over a field, where the secrets skğ‘– lie) by setting:
ğ‘“ğ‘– (0) = skğ‘– and for all ğ‘— âˆˆ ğµ: ğ‘“ğ‘– ( ğ‘—) = ğœğ‘–,ğ‘— . Then it evaluates
ğ‘“ğ‘– (âˆ’1), ğ‘“ğ‘– (âˆ’2), . . . , ğ‘“ğ‘– (âˆ’(ğ‘› âˆ’ ğ‘¡ âˆ’ 1)) and publishes them.
Given the above protocol, the recovery protocol works simply
by requiring the key-owner ğ‘ƒğ‘– to interact with (ğ‘¡ + 1) guardians
{ğ‘ƒ ğ‘— } ğ‘— âˆˆğ‘… for ğ‘… âŠ† ğµ and |ğ‘…| = ğ‘¡ + 1 as follows:
â€¢ ğ‘ƒğ‘– reaches out to any (ğ‘¡ + 1) guardians {ğ‘ƒ ğ‘— } ğ‘— âˆˆğ‘… .
â€¢ Each guardian recomputes ğœğ‘–,ğ‘— := H(ğ‘–, sk ğ‘— ) and sends back.
â€¢ On receiving (ğ‘¡ + 1) shares {ğœğ‘–,ğ‘— } ğ‘— âˆˆğ‘… , ğ‘ƒğ‘– interpolates skğ‘– :=
ğ‘“ğ‘– (0) using ğ‘› distinct evaluation points combining these
(ğ‘¡ + 1) evaluation points ğ‘“ğ‘– ( ğ‘—) := ğœğ‘–,ğ‘— and (ğ‘› âˆ’ ğ‘¡ âˆ’ 1) public
evaluation points ğ‘“ğ‘– (âˆ’1), ğ‘“ğ‘– (âˆ’2), . . . , ğ‘“ğ‘– (âˆ’(ğ‘› âˆ’ ğ‘¡ âˆ’ 1)). In the
gas cost, which scales linearly with the number of backups. Instead, one may just put
a hash of the points, and store the point themselves off-chain.

Aniket Kate, Pratyay Mukherjee, Hamza Saleem, Pratik Sarkar, and Bhaskar Roberts

end it checks whether skğ‘– is the correct key with respect to
public pkğ‘– .
Figure 1 provides a workflow of our scheme for the case where
ğ‘› = 4 and ğ‘¡ = 1. Party ğ‘ƒ 1 first creates a backup of key sk1 by
interacting with parties ğ‘ƒ 2 , ğ‘ƒ3 , and ğ‘ƒ 4 , as illustrated in Figure 1a.
The public evaluation shares ğœ‘ 1 are published on the bulletin board.
In the event of key loss, party ğ‘ƒ1 can interact with ğ‘¡ + 1 parties i.e.
ğ‘ƒ2 and ğ‘ƒ3 in this example, and the public bulletin board to recover
the key, as shown in Figure 1b.
Let us remark a few important things about our protocols: first,
note that as long as adversary corrupts at most ğ‘¡ parties then it gets
ğ‘¡ shares. Given (ğ‘›âˆ’ğ‘¡ âˆ’1) public points, the adversary knows at most
(ğ‘› âˆ’ 1) evaluation points, insufficient to recover any information
about skğ‘– . Second, if ğ‘ƒ ğ‘— works as a guardian for different key owners
ğ‘– 1, . . . , ğ‘–ğ‘š , all shares ğœğ‘– 1 ,ğ‘— = H(ğ‘– 1, sk ğ‘— ), . . . , ğœğ‘–ğ‘š ,ğ‘— = H(ğ‘–ğ‘š , sk ğ‘— ) are
uncorrelated and independent as long as sk ğ‘— is hidden, assuming H
is a random oracle. Thirdly, ğœğ‘–,ğ‘— does not leak anything about sk ğ‘—
as long as sk ğ‘— is hard to predict given pk ğ‘— , due to random oracle
properties of H as well. Furthermore, here the guardians do not
need to know each other, as ğµ is never made public â€“ as mentioned
in [8], this reduces the chance of collusion, as first they need to
figure out the set ğµ. We note that, in our protocol, during recovery
a key-owner must remember the backup set ğµ, as she needs to
reach out to a (ğ‘¡ + 1) size subset of that set. This is relatively easy
information to remember, as also pointed out in [8], and plausibly
is necessary too.
Malicious security comes virtually for free. This is because, a
malicious key-owner can only hurt herself, and thus can not do
worse than a semi-honest key-owner. A malicious guardian may
send arbitrary computation at either the backup or recovery phase.
But that would still leave enough entropy to the secret. An inconsistent behavior, such as sending different values at the time of
backup and recovery would yield a faulty recovery of skğ‘– . But since
this is checked against the public key pkğ‘– at the very last step of
the recovery protocol, the key-owner would be able to catch this
behavior and abort. However, the key-owner would not be able to
identify the cheater as our protocol does not support identifiable
abort â€“ we leave that as an interesting open question for the future.
Our protocol can be proven secure against adaptive corruption,
where the adversary may corrupt parties at any time during the
execution. The main challenge to achieve this, with respect to a
simulation-based definition, such as ours, is the following scenario:
the simulator simulates an honest party ğ‘ƒ ğ‘— â€™s response, say ğœğ‘–,ğ‘— in a
backup protocol initiated by a corrupt key-owner ğ‘ƒğ‘– , without its
secret key sk ğ‘— , and then later ğ‘ƒ ğ‘— gets corrupted leaking the entire
secret state of ğ‘ƒ ğ‘— â€“ at that point, the simulator (who now also obtains
sk ğ‘— ) needs to ensure that the leaked secret state is consistent with
the prior responses. This is handled by programming the random
oracle to ğœğ‘–,ğ‘— := H(ğ‘–, sk ğ‘— ) adaptively. In another scenario, when
a key-owner ğ‘ƒğ‘– gets adaptively corrupt, after a backup session,
then too such programming is needed. However, now the simulator
needs to ensure that the public points, published during the backup
session, are consistent with the secret key skğ‘– . In this case, the
simulator just samples uniform random (and hence independent)
evaluations for public points. Since not more than ğ‘¡ corruptions
are allowed, even an unbounded adversary does not obtain more

than (ğ‘¡ + 1) points (it can obtain skğ‘– from pkğ‘– by, for example, bruteforce). Once skğ‘– is available, the honest partyâ€™s responses to the
prior backup session, available in the secret state of ğ‘ƒğ‘– , needs to be
computed via interpolation (this is in contrast to the actual protocol,
where honest shares are computed independently, and public points
are interpolated). But, due to the properties of secret sharing, the
two procedure are identical, as long as up to ğ‘¡ parties are (adaptively)
corrupt. We formalize this secret sharing scheme as bottom up secret
sharing (see Section 5), and formalize this security requirement as
perfect adaptive simulation security. This formalization maybe of
independent interest.

1.3

A Domino Effect for variable thresholds

In this paper, we only consider a fixed ğ‘¡ for our design, though
our definition allows arbitrary access structures. We notice an
interesting feature for variable threshold access structure in our
protocol, which is akin to the so-called domino effect. Let us consider an access structure where each party ğ‘ƒğ‘– has threshold ğ‘¡ğ‘– , and
ğ‘¡ğ‘–+1 = (ğ‘¡ğ‘– + 1). Now, if the adversary corrupts (ğ‘¡ 1 + 1) parties, then it
may obtain the secret key of ğ‘ƒ1 since in our protocol, given a secret
key, all corresponding shares can be computed deterministically.
So, now it has (ğ‘¡ 1 + 2) = (ğ‘¡ 2 + 1) secret keys. Again, it may well be
possible now that those (ğ‘¡ 2 + 1) keys are sufficient to recover the
secret key of ğ‘ƒ2 . Continuing like this one may end up recovering
all secrets just by corrupting ğ‘¡ 1 + 1 parties. However, in our definition, this does not show up because we do not allow corruption of
more than ğ‘¡ 1 parties. Also note that, if parties have more unknown
variables, such as passwords, or other hidden randomnesses, such
effects can be mitigated, at least partially. We leave further exploration of variable threshold access structure as an interesting future
work.

1.4

Roadmap

We present the related works in the literature in Section 2. We
present the necessary preliminaries in Section 3. We formally define Social Key recovery in Section 4. Then we define and construct BUSS in Section 5. Using BUSS we construct our Social Key
Recovery protocol in Section. 6. We also implement our scheme.
We benchmark in both regional and geo-distributed settings and
present evaluations in Section 7. Finally, we briefly describe a number of extensions in Section 8.

2

RELATED WORK

Smart-contract based Social Recovery [8, 20]. In [8] Buterin refers
to a social key recovery protocol, that is operated via a smart contract, which is executed when a recovery is initiated by the keyowner, the guardians sign a special transaction that recovers the
fund. However, this is a non-cryptographic solution, and the original secret key is not recovered. In contrast, our solution enables
the key-owner to recover the original secret-key, which may be
used for any desired purpose, subsequently. So, from that perspective, our solution is more general and uses cryptography instead of
relying on the smart-contractâ€™s capability. The only functionality
we need from the blockchain is to support an immutable bulletin
board that would store the public points, or their hashes, reliably.
A similar solution was proposed in [20], which additionally uses

ANARKey: A New Approach to (Socially) Recover Keys

encryption of shares where the decryption key is further split into
shares. Nevertheless, this also enables recovering funds instead of
secret keys. Also, both of these solutions suffer from scalability
issues in our community setting where the same guardian is used
by many key-owners.
There are other key-recovery / account recovery designs that
consider mainly a client-server setting, in that servers are typically
assumed to store secret information per user, can do much heavier
computation than the clients, and also are available during recovery.
Those solutions are not directly compatible in our social recovery
setting in a community but may offer new technical insights for
future adaptation. We discuss a few of them below.

the user produces the keycard combined with a user passphrase and
other personal inputs to build a transaction that sends the account
funds to a new address. There are other [6] recovery schemes that
allow funds recovery. The schemes of Sequence [22] and Torus [28]
also generate multiple keys during the account creation. These keys
are used to recover the account upon loss of the main signing key.
Zengo [30] creates secret shares of the wallet key and stores one
share on the userâ€™s device and the other share is stored securely
(encrypted under the Zengo public key) with the Zengo servers.
To execute a transaction, both secret shares are used to sign. To
recover the key, the user needs to authenticate itself via biometrics
and then recover the key using the two shares.

Coinbase WaaS: Key-recovery using MPC [17]. Recently in a whitepaper [17], Lindell describes a key recovery solution for Coinbaseâ€™s
wallets-as-a-service or WaaS. The whitepaper describes two designs
for key-recovery using interactive protocols without formalization.
In the first design, the secret key is encrypted5 , then uploaded in the
cloud and the decryption key is stored in a secure enclave. Together,
the ciphertext and decryption key are sufficient to recover the wallet key. In their second design, the decryption key is split into two
additive shares, one held by the wallet-owner (i.e. key-owner) in the
cloud and one held by Coinbase server â€“ as stated in the whitepaper, this design is easier to use and has more resilience against loss
because the user does not need to store any information on their
local device. Nevertheless, the designs are not really compatible
with the social recovery paradigm, because they fundamentally rely
on existence (and availability) of a reliable server maintained by
Coinbase, that receives and stores back-up information from each
user and participates in signing every transaction from the user.
Compared to that, our design relies on a community with an access
structure, that can be any (ğ‘¡ + 1) of the whole set of guardians.
Furthermore, the guardians are not relied upon to store backup
information, such as ciphertexts or random shares, from the user â€“
they only store their own secret keys. Moreover, they only need to
interact with the user during back-up and recovery â€“ so the internal
secret storage of a guardian does not increase with the number of
supported backups.

Login using Web2 methods: Mysten Labâ€™s ZKLogin [24], Aptos
KeyLess [1]. In these two very similar designs, the high-level idea is
to use Web2 authentication methods to enable Web3 authentication.
The biggest benefit of these approaches is that the user can just be a
native Web2 user, without ever requiring to manage any key. So, the
need for any wallet is totally dispensed with. While we recognize
that these approaches would indeed be greatly useful to bring more
Web2 user onboard to Web3 ecosystems, they still rely on servers
controlled by large-scale corporations such as Google and hence is
not really compatible with the decentralization paradigm of Web3.
So, any social recovery approach, including our approach may be
viewed as a complementary solution for a community where users
are already native to the Web3 ecosystem.

Account Recovery for a Privacy-Preserving Web Service [18]. Account recovery with a server has been considered in a privacypreserving setting, where the account information, such as user
names, passwords, or even the security questions must be hidden
from the server. This solution uses cryptographic techniques such
as oblivious PRFs along with rate limiters to ensure privacy but
relies on the user remembering the information such as passwords,
security questions, etc, and relies on external servers.
There are many more key / account recovery approaches, e.g.
off-chain backup using 2FA [2], pre-signed transactions [25] which
are applicable in settings that are even more different from ours.
For a comprehensive study we refer to the SoK [10]. There are
protocols [2] that rely on cloud services and allows the user to
backup-recover their keys via 2-factor authentication methods. In
the BitGo recovery scheme [5] the user generates a backup key and
main wallet key. The user needs to store a â€œkeycardâ€ that contains
an encrypted version of the main and backup key. To recover funds
5 In more detail, the wallet key is split into two shares, and both shares are encrypted.

Adept Secret Sharing [4]. Bellare, Dai and Rogaway proposed the
notion of adept secret sharing in [4]. In addition to the standard
guarantee such as privacy, adept secret sharing offers new properties such as authenticity and error correction. Their authenticity
notion guarantees that a party can verify whether a reconstructed
secret is correct or not. This is achieved by storing a commitment of
the secret in a reliable public storage ahead of time, and then check
with that after reconstruction. Looking ahead, our social recovery
scheme achieves malicious security in a similar way by checking
with the public key which is essentially a commitment of the secret key, though we do not include this property in our notion of
bottom-up secret sharing. Moreover, their construction uses a PRF
to generate the coefficients of the secret polynomials, whereas our
construction (Section 5.1) uses a hash function to define the evaluation points of the secret polynomial. Nevertheless, despite some
technical similarities, they did not consider a bottom-up approach.

3

NOTATION AND PRELIMINARIES

Notations. We use N to denote a set of positive integers, and [ğ‘›]
to denote the set {1, . . . , ğ‘›} for any ğ‘› âˆˆ N. We denote the security
parameter by ğœ† âˆˆ N. A set ğ‘‹ = {ğ‘¥ 1, . . . , ğ‘¥ğ‘› } is denoted as ğ‘¥ [ğ‘›] or
{ğ‘¥ğ‘– }ğ‘– âˆˆ [ğ‘›] . For any subset ğ‘† âŠ‚ [ğ‘›], ğ‘¥ğ‘† or {ğ‘¥ğ‘– }ğ‘– âˆˆğ‘† denotes the subset
of ğ‘‹ containing all ğ‘¥ğ‘– â€™s such that ğ‘– âˆˆ ğ‘†. A ordered tuple (ğ‘¥ 1, . . . , ğ‘¥ğ‘› )
is denoted by vector notation ğ‘¥Â®[ğ‘›] or (ğ‘¥ğ‘– )ğ‘– âˆˆ [ğ‘›] . Similarly for any
subset ğ‘† of [ğ‘›], ğ‘¥Â®ğ‘† and (ğ‘¥ğ‘– )ğ‘– âˆˆğ‘† are defined.
Every algorithm takes ğœ† as an input, even if not always mentioned explicitly; all definitions work for sufficiently large choice of
ğœ†. We use negl to denote a negligible function, which is defined to be
a function ğ‘“ : N â†’ R, such that for every polynomial ğ‘, there exists
an ğ‘› âˆˆ N such that for all ğœ† > ğ‘›, it holds that ğ‘“ (ğœ†) < 1/ğ‘ (ğœ†). We

Aniket Kate, Pratyay Mukherjee, Hamza Saleem, Pratik Sarkar, and Bhaskar Roberts

â€¢ Î  Init . In this protocol, a party ğ‘ƒğ‘– locally generates a key
pair (skğ‘– , pkğ‘– ) either computing (skğ‘– , pkğ‘– ) â† KeyGen(1ğœ† )
or using another algorithm, specified by the protocol.7 Each
party ğ‘ƒğ‘– publishes pkğ‘– . An execution is denoted by:

use ğ‘¦ := ğ· (ğ‘¥) to denote a deterministic computation and ğ‘¦ := ğ‘¥ for
assignment. Randomized computations are denoted as ğ‘¦ â† ğ‘…(ğ‘¥).
The symbol âŠ¥ denotes undefined value, or invalidity.
We model computationally bounded adversaries by probabilistic
polynomial time (PPT) algorithms. We also consider our adversaries
to be interactive algorithms A, which can be rigorously modeled
as interactive Turing machines. An algorithm A with oracle access
to an oracle O is denoted as A O (Â·) . We say a particular problem
is computationally hard to imply that for any PPT adversary, the
probability of solving a random instance of that problem is bounded
by negl(ğœ†).
Adversarial Model. We consider adaptive and malicious PPT adversaries. By malicious we mean that the adversary can behave
arbitrarily in the protocol. Looking ahead, security against malicious adversary basically comes for free, as a malicious adversary,
at best, can invoke an abort. Adaptive adversaries can corrupt parties at any time during the execution â€“ this model of corruption is
much more realistic than a weaker static adversarial model, where
the corrupted set of parties does not change since the start of the
execution. Handling adaptive security in our protocol is more challenging. We also assume there is no erasure, so any partyâ€™s secret
state can only be appended, but not deleted â€“ in this setting adaptive corruptions are particularly difficult to analyze, because in a
simulation any honest partyâ€™s secret state at any point must be
â€œexplainedâ€ consistently with respect to prior messages, if that party
gets corrupted at a later point during the execution. Note that the
â€œno erasureâ€ assumption does not contradict the essence or utility
of a key recovery protocol, because recovery takes place rather
infrequently, typically for accidental deletion / loss of the secret
key.

4

DEFINITION

In this section we present our formal definitions. Note that, the social recovery scheme defined below does not require the guardians
to remember any secret back-up information other than their own a
priori generated sk using KeyGen. It suffices for the back-up procedure Î  Back to produce only public back-up information pub. Also,
we define the scheme for a setting when there is a single KeyGen.
But it is straightforward to extend to a setting with multiple partyspecific key-generation procedures.
Definition 4.1 (Social Key Recovery Scheme (SKR)). Consider ğ‘
parties ğ‘ƒ1, . . . , ğ‘ƒ ğ‘ , and define an access structure ğ”„ which consists
of pair of sets (ğµ, ğ‘…) such that ğµ âŠ† [ğ‘ ] and ğ‘… âŠ† ğµ. We assume without loss of generality that each party ğ‘ƒğ‘– has an established public
identity-ğ‘–.6 Let KeyGen be a key generation algorithm, which produces a pair of keys (sk, pk) â† KeyGen(1ğœ† ). Then a social recovery
scheme Î  SKR between ğ‘ parties ğ‘ƒ1, . . . , ğ‘ƒ ğ‘ for KeyGen and access
structure ğ”„ consists of a triple of protocols (Î  Init, Î  Back, Î Rec ) executed among a subset of the parties in the following order: first
Î Init is executed by all parties; then each party may initiate an
instance of Î  Back once with a subset of parties in ğµ âŠ† [ğ‘ ]; finally
once ğ‘ƒğ‘– has finished executing Î  Back , it can initiate Î Rec arbitrarily
many times. The protocols have the following syntax:

ğœ† ğ‘
Â®
Â®
( pk
[ğ‘ ] , sk [ğ‘ ] ) â† Î  Init (1 , 1 )

Once this is completed, the below protocols may be exeÂ®
cuted by each party ğ‘ƒğ‘– with the same public input pk
[ğ‘ ] .
â€¢ Î  Back : In this protocol, a key owner ğ‘ƒğ‘– who wishes to back
up her secret key skğ‘– interacts with a set of guardians
{ğ‘ƒ ğ‘— } ğ‘— âˆˆğµ . Each guardian ğ‘ƒ ğ‘— uses secret key sk ğ‘— . The protocol concludes with a public back-up string pubğ‘– . We denote
such execution by:
Â® , sk
Â® ğµâˆª{ğ‘– } )
pubğ‘– â† Î Back (ğ‘–, ğµ, pk
ğµ
â€¢ Î  Rec : If ğ‘ƒğ‘– wishes to recover skğ‘– using a recovery set ğ‘…, she
runs this protocol without any secret input with a set of
guardians {ğ‘ƒ ğ‘— } ğ‘— âˆˆğ‘… , each of which uses their secret key sk ğ‘— .
In addition, pubğ‘– may be used by all parties. At the end of
this protocol, the key-owner may receive a private output
skğ‘– (or âŠ¥ if unsuccessful). One such execution is denoted
as:
Â® , pub , sk
Â® ğ‘…)
skğ‘– /âŠ¥ â† Î  Rec (ğ‘–, ğ‘…, pk
ğ‘…
ğ‘–
Correctness. For correctness we require that for any sufficiently large
ğœ†, any ğ‘– âˆˆ [ğ‘ ], any (ğµ, ğ‘…) âˆˆ ğ”„:
"
Â® , pub , sk
Â® ğ‘…)
Pr skğ‘– â† Î Rec (ğ‘–, ğ‘…, pk
ğ‘…
ğ‘–

ğœ† ğ‘
Â®
Â®
( pk
[ğ‘ ] , sk [ğ‘ ] ) â† Î  Init (1 , 1 );

Â® , sk
Â® ğµâˆª{ğ‘– } )
pubğ‘– â† Î Back (ğ‘–, ğµ, pk
ğµ

#
=1

Security. For the security of Î SKR for a given KeyGen and ğ”„, we need
that for any sufficiently large ğœ† âˆˆ N there exists a PPT simulator S
in the ideal world, such that for any ğ‘ and any PPT adversary A
we have that:
Real A (1ğœ† , 1ğ‘ , ğ”„, KeyGen, Î  SKR ) â‰ˆğ¶
Ideal S,A (1ğœ† , 1ğ‘ , ğ”„, KeyGen, Î  SKR ).
The experiments are described below, where we denote the set of
corrupted parties at any point as ğ¶ and the set of honest parties as
ğ» = [ğ‘ ] \ ğ¶. At any point, the adaptive adversary may corrupt an
honest party and then gets full control of that party and its secret
state.
Real A (1ğœ† , 1ğ‘ , ğ”„, KeyGen, Î SKR ):
â€¢ Initialize ğ¶ := âˆ… and a list ğ¿ := âˆ….
ğœ† ğ‘
Â®
Â®
Â®
â€¢ Run ( pk
[ğ‘ ] , sk [ğ‘ ] ) â† Î  Init (1 , 1 ) and give pk [ğ‘ ] to the
O
(Â·),O
(Â·),O
Rec (Â·),ORO (Â·) .
Back
adversary with oracle access: A Cor
â€¢ When A returns an output Out A , output (Out A , Out H )
where Out H is the output of all honest parties. Each honest
partyâ€™s output is undefined, until that party initiates Î Rec .
If that execution succeeds then the output is defined to be
the recovered secret key, skğ‘– , otherwise it is defined to be
âŠ¥. If no such session is ever initiated, then the output stays
undefined at the end.
7 It is also possible that a party sets either or both of the keys to âŠ¥. In our protocol,

6 For example the generated public key can serve as an identity. Without loss of

generality we denote the identity of ğ‘ƒğ‘– simply by an integer-ğ‘– .

however, we consider each party executes a standard KeyGen, e.g. for specific signature
schemes.

ANARKey: A New Approach to (Socially) Recover Keys

Ideal A,A (1ğœ† , 1ğ‘ , ğ”„, KeyGen, Î  SKR ):
â€¢ Initialize ğ¶ := âˆ… and a list ğ¿ := âˆ….
ğœ† ğ‘
Â®
Â®
Â®
â€¢ Run ( pk
[ğ‘ ] , sk [ğ‘ ] ) â† Î  Init (1 , 1 ) and give pk [ğ‘ ] to the
S
(Â·),S
(Â·),S
Cor
Rec (Â·),SRO (Â·) .
Back
adversary with oracle access: A
â€¢ When A returns an output Out A , output (Out A , Out H )
and stop, where Out H is defined below within SRec .
Here ORO is a random oracle and SRO is the random oracle simulated by the simulator. The rest of the oracles are defined below,
where we highlight the part where it differs in case of simulator by
blue.
OCor (ğ¶ â€² )/SCor (ğ¶ â€² ):
â€¢ Update ğ¶ := ğ¶ âˆª ğ¶ â€² . Run CorCheckğ”„ (ğ¿, ğ¶), if it returns 1,
then abort.
â€¢ If not, then for each ğ‘– âˆˆ ğ¶ â€² , give the secret state of party
Â® ğ¶ â€² to S, who sends a
ğ‘ƒğ‘– to A. For SCor , instead give sk
simulated secret state to A.
OBack (ğ‘–, ğµ)/SBack (ğ‘–, ğµ):
â€¢ If there is an entry (ğ‘–, âˆ—, âˆ—) âˆˆ ğ¿, then skip.
Â® , sk
Â® ğµâˆª{ğ‘– } ) using the honest
â€¢ Else run pub â† Î  Back (ğ‘–, ğµ, pk
ğµ
parties ğ‘ƒğ» and allowing A to control the corrupt parties
Â®ğ»
ğ‘ƒğ¶ . For SBack , let S control the honest parties without sk
â€“ A still controls the corrupt parties.
â€¢ Then store (ğ‘–, ğµ, pub) into ğ¿.
â€¢ Run CorCheckğ”„ (ğ¿, ğ¶), if it returns 1, then abort.
ORec (ğ‘–, ğ‘…)/SRec (ğ‘–, ğ‘…):

Out H . If the recovery fails, then the output is defined to be âŠ¥. The
simulated oracle SRec handles this case in the proof.

5

BOTTOM-UP SECRET SHARING

Consider a set of ğ‘ parties ğ‘ƒ1, . . . , ğ‘ƒ ğ‘ , where each party ğ‘ƒğ‘– has an
established identity denoted simply by ğ‘– âˆˆ [ğ‘ ]. We formalize a
secret-sharing scheme for a (ğ‘¡ + 1)-out-of-(ğ‘› âˆ’ 1) access structure,
(first used in [3] to construct multiverse threshold signatures, albeit
without any formalization), that allows each party to choose their
shares independently of the other partiesâ€™ shares and even of the
secret.
Definition 5.1 (Bottom-Up Secret Sharing (BUSS)). For ğ‘›, ğ‘¡, ğ‘ âˆˆ N
such that ğ‘¡ + 1 â‰¤ ğ‘› âˆ’ 1 < ğ‘ , a bottom-up secret sharing scheme for
a (ğ‘¡ + 1)-out-of-(ğ‘› âˆ’ 1) threshold access structure over the set [ğ‘ ]
consists of algorithms with the following syntax:
â€¢ Share(ğ‘ , ğœÂ®ğµ , ğµ): Takes as input a secret ğ‘ , (ğ‘› âˆ’ 1) shares ğœÂ®ğµ ,
and the corresponding set of indices ğµ âŠ† [ğ‘ ] \ {ğ‘–} such
that |ğµ| = ğ‘› âˆ’ 1. Then Share outputs a public value ğœ‘.
â€¢ Recon(ğœ‘, ğœÂ®ğ‘… , ğ‘…): Takes as input the public value ğœ‘, (ğ‘¡ + 1)
shares ğœÂ®ğ‘… , and the corresponding set of indices ğ‘… âŠ† [ğ‘ ]
such that |ğ‘…| = ğ‘¡ + 1. Then Recon outputs a secret ğ‘  or
outputs âŠ¥ if the procedure fails.
Furthermore, the BUSS scheme satisfies the following notions of
correctness and perfect adaptive simulation security.
Correctness. For any secret ğ‘ , any sets ğ‘…, ğµ such that ğ‘… âŠ† ğµ âŠ‚
[ğ‘ ], |ğ‘…| = (ğ‘¡ + 1), |ğµ| = (ğ‘› âˆ’ 1), and any ğœÂ®ğµ :

â€¢ If there is no entry (ğ‘–, âˆ—, âˆ—) in ğ¿, then skip.


Pr ğ‘  â† Recon(ğœ‘, ğœÂ®ğ‘… , ğ‘…) ğœ‘ â† Share(ğ‘ , ğœÂ®ğµ , ğµ) = 1
Â® , pub, sk
Â® ğ‘…)
â€¢ Else retrieve (ğ‘–, ğµ, pub) from ğ¿ and run Î Rec (ğ‘–, ğ‘…, pk
ğ‘…
using the honest parties ğ‘ƒğ» and allowing A to control the
Perfect Adaptive Simulation Security. For any unbounded adversary
corrupt parties ğ‘ƒğ¶ . For SRec , let S control the honest parA, there exists a pair of algorithms (SimShare, SimComb) such
Â® ğ» â€“ A still controls the corrupt parties. Also,
ties without sk
that the following two distributions are identical.
the honest partyâ€™s output vector Out H is defined within
â€¢ RealSh A :
SRec .
â€“ Receive (ğ‘ , ğœÂ®ğ¶ , ğ¶, ğµ) from A, such that ğ¶ âŠ† ğµ, |ğ¶ | â‰¤ ğ‘¡,
The following predicate CorCheckğ”„ checks whether it is posand |ğµ| = (ğ‘› âˆ’ 1).
sible for the adversary to recover an honest partyâ€™s key trivially
â€“ Sample ğœÂ®ğµ\ğ¶ uniformly at random.
through corrupting more than what is allowed.
â€“ Run ğœ‘ â† Share(ğ‘ , ğœÂ®ğµ , ğµ), and give ğœ‘ to A.
CorCheckğ”„ (ğ¿, ğ¶):
â€“ When A queries (Share, ğ¶ â€² ) for ğ¶ â€² âŠ† ğµ \ ğ¶, update
ğ¶ := ğ¶ âˆª ğ¶ â€² . If |ğ¶ | > ğ‘¡, then abort. If not, then give ğœÂ®ğ¶ â€²
â€¢ If there exists an (ğ‘–, ğµ, pub) âˆˆ ğ¿ and ğ‘… âŠ† ğ¶ for which ğ‘– âˆˆ ğ»
to A.
and (ğµ, ğ‘…) âˆˆ ğ”„ then return 1. Otherwise, return 0.
â€“ Finally give ğœÂ®ğµ\ğ¶ .
Remark 4.1. Here for simplicity we assume that the backup protocol
â€“ Output whatever A returns.
is executed only once by each party. In reality it can be executed
â€¢ IdealSh A :
multiple times. Our definition can be extended to that easily. Looking
â€“ Receive (ğ‘ , ğœÂ®ğ¶ , ğ¶, ğµ) from A, such that ğ¶ âŠ† ğµ, |ğ¶ | â‰¤ ğ‘¡,
ahead, our construction (given in Section 6), would need some simple
and |ğµ| = (ğ‘› âˆ’ 1).
changes to make it work in that setting. In particular, a unique session
â€“ Run ğœ‘, ğœÂ® â† SimShare(ğ¶) and give ğœ‘ to A.
id, which, in combination with the party id, should be used in place
â€“ When A queries (Share, ğ¶ â€² ) for ğ¶ â€² âŠ† ğµ \ ğ¶, update
of only party id.
ğ¶ := ğ¶ âˆªğ¶ â€² and ğœÂ®ğ¶ â€² = ğœÂ®ğ¶ â€² . If |ğ¶ | > ğ‘¡, then abort. If not,
then give ğœÂ®ğ¶ â€² to A.
Remark 4.2. We stress that our protocol captures security with abort,
â€“
Finally compute ğœÂ®ğµ\ğ¶ â† SimComb(ğ‘ , ğµ, ğ¶, ğœÂ®ğ¶ , ğœ‘) and
in that a malicious adversary (in our case, can also be adaptive) can
give ğœÂ®ğµ\ğ¶ to A.
define the honest partyâ€™s output to be abort. This is captured formally
â€“
Output whatever A returns.
by our definition by including all honest partyâ€™s outputs in the variable
Out H . At the beginning each honest partyâ€™s output stays undefined.
For every honest party-ğ‘–, that initiates a recovery protocol Î  Rec , if a
recovery succeeds, then a correct output, namely skğ‘– is included into

The notion of perfect adaptive simulation security says morally that
the real-world ğœ‘ does not reveal any information about ğ‘  or any
partyâ€™s shares to the adversary. Note that in IdealSh A , SimShare

Aniket Kate, Pratyay Mukherjee, Hamza Saleem, Pratik Sarkar, and Bhaskar Roberts

computes the public value ğœ‘ given only ğ¶ as input, so ğœ‘ does not
depend on ğ‘  or on any partyâ€™s shares.
Furthermore, we allow the adversary to adaptively corrupt parties by making queries of the form (Share, ğ¶ â€² ). On such a query,
the adversary learns the shares ğœÂ®ğ¶ â€² as long as the total number of
parties that theyâ€™ve corrupted remains â‰¤ ğ‘¡.

5.1

Constructing BUSS

We construct a simple BUSS scheme for a (ğ‘¡ + 1)-out-of-(ğ‘› âˆ’ 1)
threshold access structure over a finite field F as follows:
â€¢ Share(ğ‘ , ğœÂ®ğµ , ğµ):
Define a polynomial ğ‘“ over F of degree (ğ‘› âˆ’ 1) such that
ğ‘“ (0) := ğ‘  and for all ğ‘— âˆˆ ğµ:ğ‘“ ( ğ‘—) := ğœ ğ‘— . Then output ğœ‘ :=
ğ‘“ (âˆ’1), . . . , ğ‘“ âˆ’ (ğ‘› âˆ’ ğ‘¡ âˆ’ 1) .
â€¢ Recon(ğœ‘, ğœÂ®ğ‘… , ğ‘…):

Parse ğœ‘ as ğ‘“ (âˆ’1), . . . , ğ‘“ âˆ’ (ğ‘› âˆ’ ğ‘¡ âˆ’ 1) . Concatenate these
(ğ‘› âˆ’ ğ‘¡ âˆ’ 1) points with the following |ğ‘…| = ğ‘¡ + 1 points:
{ğ‘“ ( ğ‘—) := ğœ ğ‘— } ğ‘— âˆˆğ‘… . Then use Lagrange interpolation to compute the unique polynomial ğ‘“ of degree ğ‘› âˆ’ 1 that passes
through those ğ‘› points. Finally output ğ‘  := ğ‘“ (0).
Theorem 5.1 (BUSS Construction). The above construction is a
bottom-up secret sharing scheme according to Definition 5.1.
Proof. We show correctness and perfect adaptive simulation
security separately.
Correctness: The polynomial ğ‘“ that is computed by Share(ğ‘ , ğœÂ®ğµ , ğµ)
has degree (ğ‘› âˆ’ 1), so it is uniquely determined by any ğ‘› points
on the polynomial. Next, Recon knows the value of ğ‘“ (ğ‘¥) for every
ğ‘¥ âˆˆ {âˆ’1, . . . , âˆ’(ğ‘› âˆ’ ğ‘¡ âˆ’ 1)} âˆª ğ‘…. This constitutes ğ‘› points on the
polynomial because |ğ‘…| = ğ‘¡ + 1. Then Recon will reconstruct the
polynomial ğ‘“ that was computed by Share, and it will compute the
correct value ğ‘  = ğ‘“ (0).
Perfect Adaptive Simulation Security: Let us first construct
SimShare(ğ¶) and SimComb(ğ‘ , ğµ, ğ¶, ğœÂ®ğ¶ , ğœ‘) as follows:
$

$

â€¢ SimShare(ğ¶): Sample ğœ‘ â† Fğ‘›âˆ’ğ‘¡ âˆ’1 and ğœÂ® â† Fğ‘›âˆ’1 , and
output (ğœ‘, ğœ).
Â®
â€¢ SimComb(ğ‘ , ğµ, ğ¶, ğœÂ®ğ¶ , ğœ‘):
(1) Partition ğ» = ğµ \ ğ¶ into two disjoint sets ğ» â€² and ğ» â€²â€²
such that |ğ» â€² | = ğ‘¡ âˆ’ |ğ¶ |. 8

that |ğ» â€² | = ğ‘¡ âˆ’ |ğ¶ 1 |. This is possible assuming that |ğ¶ 1 | â‰¤ ğ‘¡. Note
that ğµ can be partitioned into (ğ¶ 0, ğ¶ 1 \ğ¶ 0, ğ» â€², ğ» â€²â€² ).
The variables (ğ‘ , ğœÂ®ğ¶1 , ğœÂ®ğ» â€² , ğœ‘) together define ğ‘› points on the
polynomial ğ‘“ . Since ğ‘“ has degree (ğ‘› âˆ’ 1), these ğ‘› points uniquely
determine ğ‘“ . Then for any (ğ‘ , ğœÂ®ğ¶1 , ğœÂ®ğ» â€² ) and ğœ‘, there is a unique
ğœÂ®ğ» â€²â€² such that ğœ‘ = Share(ğ‘ , (ğœÂ®ğ¶1 âˆª ğœÂ®ğ» â€² âˆª ğœÂ®ğ» â€²â€² ), ğµ).
Furthermore, (ğ‘ , ğœÂ®ğ¶1 , ğœÂ®ğ» â€² , ğœÂ®ğ» â€²â€² ) also define ğ‘› points on ğ‘“ . So
for any (ğ‘ , ğœÂ®ğ¶1 , ğœÂ®ğ» â€² ) and ğœÂ®ğ» â€²â€² , there is a unique ğœ‘ such that ğœ‘ =
Share(ğ‘ , (ğœÂ®ğ¶1 âˆª ğœÂ®ğ» â€² âˆª ğœÂ®ğ» â€²â€² ), ğµ).
In RealSh A , ğœÂ®ğµ\ğ¶0 is sampled uniformly at random. Then ğœ‘ is
uniformly random due to the randomness of ğœÂ®ğ» â€²â€² which is hidden
from the adversary. Furthermore, on each query (Share, ğ¶ â€² ), A
receives freshly random shares ğœÂ®ğ¶ â€² that are independent of their
view so far, or they receive âŠ¥. Finally, A receives ğœÂ®ğ» â€² , which is
uniformly random and independent of Aâ€™s view so far, and ğœÂ®ğ» â€²â€² ,
which is the unique value for which ğœ‘ = Share(ğ‘ , (ğœÂ®ğ¶1 âˆª ğœÂ®ğ» â€² âˆª
ğœÂ®ğ» â€²â€² ), ğµ).
In IdealSh A , ğœ‘ is sampled uniformly at random by SimShare.
Then on each query (Share, ğ¶ â€² ), A receives ğœÂ®ğ¶ â€² = ğœÂ®ğ¶ â€² , which was
sampled (as candidate future corruption shares) independently of
the adversaryâ€™s view so far, by SimShare. Finally, SimComb samples
ğœÂ®ğ» â€² uniformly at random and chooses ğœÂ®ğ» â€²â€² to be the unique value
for which ğœ‘ = Share(ğ‘ , (ğœÂ®ğ¶1 âˆª ğœÂ®ğ» â€² âˆª ğœÂ®ğ» â€²â€² ), ğµ).
This shows that the distribution of the values provided to A is
the same in RealSh A and IdealSh A . Then Aâ€™s final output will be
identically distributed in both hybrids.
â–¡
This concludes the proof of the theorem.

6

â–¡

OUR SOCIAL KEY RECOVERY SCHEME

Key Generation. We consider a KeyGen algorithm which generates a key-pair (sk, pk). KeyGen has the following requirements.
(1) We assume that for every pk there exists a unique sk such
that (pk, sk) are a valid output of KeyGen.
(2) One can efficiently verify whether a given (pk, sk) are a
valid output of KeyGen.
(3) It is hard to guess sk given pk. More formally, we say that
for any PPT adversary A,
h
i
Pr A (1ğœ† , pk) = sk : (sk, pk) â† KeyGen(1ğœ† ) â‰¤ negl(ğœ†)

$

(2) Sample ğœÂ®ğ» â€² â† Fğ‘¡ âˆ’ |ğ¶ | .
(3) Use (ğ‘ , ğœÂ®ğ¶ , ğœÂ®ğ» â€² , ğœ‘) to define ğ‘› points:
(0, ğ‘  ), ( ğ‘—, ğœ ğ‘— ) ğ‘— âˆˆğ¶âˆªğ» â€² , (âˆ’1, ğœ‘ 1 ), . . . , (âˆ’ (ğ‘› âˆ’ ğ‘¡ âˆ’ 1), ğœ‘ğ‘›âˆ’ğ‘¡ âˆ’1 )

Interpolate the unique polynomial ğ‘“ of degree ğ‘› âˆ’ 1
that passes through these points.
(4) For each ğ‘— âˆˆ ğ» â€²â€² , compute ğœ ğ‘— = ğ‘“ ( ğ‘—). Then output
ğœÂ®ğ» = ğœÂ®ğ» â€² âˆª ğœÂ®ğ» â€²â€² .
Now, we prove the following claim.
Claim 5.1. The outputs of RealSh A and IdealSh A are identically
distributed.
Proof. Let ğ¶ 0 be the value of ğ¶ at the start of the game (RealSh A
or IdealSh A ), and let ğ¶ 1 be the value of ğ¶ at the end, after the adversaryâ€™s Share queries. Let us partition ğµ\ğ¶ 1 into ğ» â€² and ğ» â€²â€² such
8 This is possible because |ğ¶ | â‰¤ ğ‘¡ and ğ‘¡ + 1 â‰¤ |ğµ | . Then |ğ¶ âˆª ğ» â€² | = ğ‘¡ .

Let this hardness assumption be known as PKeyGen .
For example, one may consider keys of the form (pk = ğ‘”sk ) for
a cyclic group generated by ğ‘” where discrete log is hard â€“ this
is a widely in many schemes, including BLS signatures, Schnorr
signatures, El-Gamal encryptions etc. It is easy to check that this
type of key generation does satisfy all of the above requirements.
We describe our main construction Î  cmnty to socially recover
keys for any KeyGen satisfying the above conditions in a community of ğ‘ parties ğ‘ƒ1, . . . , ğ‘ƒ ğ‘ for a (ğ‘¡ + 1)-out-of-ğ‘› threshold
access structure for any ğ‘¡ < ğ‘› â‰¤ ğ‘ .9 We assume a hash function H : F â†’ F, modeled as a random oracle. The construction is
provided in Figure 2.
9We note that the backup set of our access structure is of size (ğ‘› âˆ’ 1) , whereas the

recovery set is of size (ğ‘¡ + 1) . However, we call this access structure (ğ‘¡ + 1) -out-of-ğ‘› ,
as opposed to (ğ‘¡ + 1) -out-of- (ğ‘› âˆ’ 1) because also accounting for the secret, the total
number of secret/share in the system is ğ‘› .

ANARKey: A New Approach to (Socially) Recover Keys

â€“ Î Init (1ğœ† , 1ğ‘ ): Each party ğ‘ƒğ‘– :
â€¢ Runs (skğ‘– , pkğ‘– ) â† KeyGen(1ğœ† ).
â€¢ Publishes pkğ‘– and store skğ‘– .
Â® , sk
Â® ğ‘…âˆª{ğ‘– } ) : A party ğ‘ƒğ‘– runs this protocol as a
â€“ Î Back (ğ‘–, ğµ, pk
ğµ
key-owner with a set of (ğ‘› âˆ’ 1) guardians {ğ‘ƒ ğ‘— } ğ‘— âˆˆğµ as follows:
â€¢ On request from ğ‘ƒğ‘– each guardian ğ‘ƒ ğ‘— computes ğœğ‘–,ğ‘— :=
H(ğ‘–, sk ğ‘— ) and send that to ğ‘ƒğ‘– .
â€¢ The key-owner, on receiving (ğœğ‘–,ğ‘— ) ğ‘— âˆˆğµ , define ğ‘  := skğ‘–
and compute ğœ‘ â† Share(ğ‘ , (ğœğ‘–,ğ‘— ) ğ‘— âˆˆğµ , ğµ) and publish
pub := ğœ‘.
Â®
Â®
â€“ Î Rec (ğ‘–, ğ‘…, pk
[ğ‘ ] , pub, skğ‘… ): A party ğ‘ƒğ‘– runs this protocol as
a key-owner with a set of (ğ‘¡ +1) guardians {ğ‘ƒ ğ‘— } ğ‘— âˆˆğ‘… as follows:
â€¢ On request from ğ‘ƒğ‘– each guardian ğ‘ƒ ğ‘— computes ğœğ‘–,ğ‘— :=
H(ğ‘–, sk ğ‘— ) and sends that to ğ‘ƒğ‘– .
â€¢ The key-owner, on receiving (ğœğ‘–,ğ‘— ) ğ‘— âˆˆğ‘… , retrieve ğœ‘ :=
pub and compute ğ‘  â† Recon(ğœ‘, (ğœğ‘–,ğ‘— ) ğ‘— âˆˆğ‘… , ğ‘…).
â€¢ Then ğ‘ƒğ‘– checks whether (ğ‘ ğ‘– , pkğ‘– ) is a valid key-pair.
If yes then privately output skğ‘– := ğ‘ ğ‘– , else output âŠ¥.
Figure 2: The SKR protocol Î  cmnty
Remark 6.1. As mentioned earlier, instead of ğ‘– we could also use
pkğ‘– , and compute ğœğ‘–,ğ‘— := H(pkğ‘– , sk ğ‘— ) instead. This does not change
anything. Also, recall that if multiple back session is executed by the
same key-owner, we need a unique session id sid, which would be used
to derive ğœğ‘–,ğ‘— := H(sid, pkğ‘– , sk ğ‘— ) â€“ this would ensure that the shares
derived in different sessions by the same guardian are uncorrelated
(as long as sk ğ‘— is hidden).
Remark 6.2. Note that, for the protocol to work, the public values
pub just needs to be stored reliably, such that, they can be accessed
unaltered whenever needed. We may use immutable bulletin boards
to implement that, though it does not need to be accessed by all
parties, but only the key-owner during recovery. Therefore, just a
reliable storage accessible by the owner may suffice. However, in case
of permanent disappearance, e.g. demise of the owner, it is important
that the public value can be accessed by non-owners to recover the
secret, otherwise the secret will be permanently lost â€“ even if all (ğ‘› âˆ’1)
guardians come together they can not recover the secret, as the secret
polynomial in the BUSS scheme has degree (ğ‘› âˆ’ 1).
Now we analyze our protocol formally. The access structure
ğ”—ğ‘›,(ğ‘¡ +1) for which the scheme is secure contains all (ğµ, ğ‘…) for which
|ğ‘…| = (ğ‘¡ + 1), |ğµ| = (ğ‘› âˆ’ 1) and ğ‘… âŠ† ğµ. It immediately extends to ğµ
of arbitrary size, as long as it is a superset of ğ‘… â€“ we stick to equal
sized ğµ for simplicity of exposition.
Theorem 6.1. Let KeyGen be a standard key-generation algorithm
for which PKeyGen holds. Then the protocol Î cmnty among a community of ğ‘ parties ğ‘ƒ1, . . . , ğ‘ƒ ğ‘ is a secure social key recovery scheme â€“ as
per Definition 4 â€“ for access structure ğ”—ğ‘›,(ğ‘¡ +1) for any ğ‘¡ + 1 < ğ‘› â‰¤ ğ‘
against all polynomial-time malicious adaptive adversaries that corrupt â‰¤ ğ‘¡ parties.
Proof. To prove the theorem we need to show that for any
adaptive and malicious adversary A, there exists a simulator S

such that the adversaryâ€™s interactions with the oracles in the real
world are indistinguishable from its interactions with the simulated
oracles in the ideal world.
We construct the simulator as follows:
The simulator S.
â€¢ Secret states:
â€“ The simulator maintains a set ğ‘ˆ which contains elements of the form (ğ‘–, skğ‘– , ğµ, ğœÂ®ğµ , pubğ‘– ) which is essential
part of the secret state of a key owner ğ‘ƒğ‘– from an execution of backup protocol Î Back with the adversary if,
at the time of execution ğ‘ƒğ‘– was an honest party. There
can be partial entries such as (ğ‘–, âŠ¥, ğµ, ğœÂ®ğ¶âˆ©ğµ , pubğ‘– ) . If
ğ‘ƒğ‘– gets corrupted at some point, the partial entry is
updated to a complete entry (ğ‘–, skğ‘– , ğµ, ğœÂ®ğµ , pubğ‘– ), and is
given to the adversary as part of a secret state. Note
that, if ğ‘ƒğ‘– is corrupt during the execution of Î  Back ,
then no such entry is made to ğ‘ˆ .
â€“ The simulator also maintains a set ğ‘‰ containing entries of the form ( ğ‘—, ğœğ‘–,ğ‘— ). This set is populated when
a backup protocol is executed from an already corrupt key-owner ğ‘ƒğ‘– , and ğ‘ƒ ğ‘— was an honest party at that
moment. Note that, elements of this set were already
known to the adversary as transcripts of the backup
protocol even when ğ‘ƒ ğ‘— was honest. Nevertheless, since
no erasure is assumed, this should be included in the
state, and would be given to the adversary on corruption to make the simulation accurate.
â€“ The entire simulated secret state of any party ğ‘ƒğ‘– consists of (ğ‘–, skğ‘– , ğµ, ğœÂ®ğµ , pubğ‘– ) and {(ğ‘–, ğœğ‘˜,ğ‘– )}ğ‘˜ . On an adaptive corruption ğ‘ƒğ‘– , (skğ‘– , (ğœÂ®ğµ ), {ğœğ‘–,ğ‘˜ }ğ‘˜ ) is handed over
to the adversary.
â€¢ Random Oracle:
(1) ğ‘…sim (ğ‘–, ğ‘—): ğ‘…sim is internally computed and possibly
programmed by S and accepts queries of the form
(ğ‘–, ğ‘—) âˆˆ [ğ‘ ] Ã— [ğ‘ ]. Upon receiving query (ğ‘–, ğ‘—), check
if (ğ‘–, ğ‘—) has previously been queried to ğ‘…sim . If so, then
give the same response as the previous time. If not,
$

then sample ğ‘¦ â† F, store the equation ğ‘…sim (ğ‘–, ğ‘—) = ğ‘¦,
and respond with ğ‘¦.
(2) SRO (ğ‘¥): Upon a RO query ğ‘¥:
(a) Check if (1) ğ‘¥ = (ğ‘–, sk) for some ğ‘– âˆˆ [ğ‘ ] and
some key sk, and (2) (sk, pk ğ‘— ) is a valid key-pair
for some ğ‘— âˆˆ [ğ‘ ]. If both conditions are satisfied,
then respond with ğ‘…sim (ğ‘–, ğ‘—).
(b) If the conditions are not both satisfied, then
check if ğ‘¥ has been previously queried to ğ» . If so,
then give the same response as the previous time.
$

If not, then sample ğ‘¦ â† F, store the equation
ğ» (ğ‘¥) = ğ‘¦, and respond with ğ‘¦.
â€¢ The oracle SBack (ğ‘–, ğµ) is simulated as follows:
(1) If ğ‘– âˆˆ ğ» , then when the adversary returns (ğœğ‘–,ğ‘— ) ğ‘— âˆˆğ¶âˆ©ğµ ,
then run ğœ‘ğ‘– â† SimShare(ğ¶ âˆ©ğµ) and publish ğœ‘ğ‘– as pubğ‘– .
Also append (ğ‘–, âŠ¥, ğµ, (ğœğ‘–,ğ‘— ) ğ‘— âˆˆğ¶âˆ©ğµ , pubğ‘– ) in the set ğ‘ˆ .
(2) If ğ‘– âˆˆ ğ¶, then on behalf of each honest party ğ‘ƒ ğ‘— such
that ğ‘— âˆˆ ğ» âˆ©ğµ, compute ğœğ‘–,ğ‘— := ğ‘…sim (ğ‘–, ğ‘—), and send ğœğ‘–,ğ‘—

Aniket Kate, Pratyay Mukherjee, Hamza Saleem, Pratik Sarkar, and Bhaskar Roberts

â€¢ If EBad happens but ğ‘— â‰  ğ‘— âˆ— then abort. Call this event
EAbort .
ğ‘—âˆ—
â€¢ Else when EBad happens (A queries SRO (ğ‘–, sk ğ‘— âˆ— )), then
send sk ğ‘— âˆ— to the PKeyGen -challenger as the answer. Call
this event EBreak .
ğ‘—

as party ğ‘ƒ ğ‘— â€™s response to the adversary. Also append
( ğ‘—, ğœğ‘–,ğ‘— ) to set ğ‘‰ .
â€¢ The oracle SCor (ğ¶ â€² ) is simulated as follows. For each ğ‘– âˆˆ ğ¶ â€² ,
the simulator receives skğ‘– and does the following:
(1) It searches for an entry (ğ‘–, âŠ¥, ğµ, (ğœğ‘–,ğ‘— ) ğ‘— âˆˆğµâˆ©ğ¶0 , pubğ‘– ) in
ğ‘ˆ , where ğ¶ 0 is the value of ğ¶ at the time the entry was
created. If found, then:
(a) Let ğ¶ 1 = ğ¶\ğ¶ 0 . For each ğ‘— âˆˆ ğ¶ 1 , compute ğœğ‘–,ğ‘— =
ğ‘…sim (ğ‘–, ğ‘—).
(b) Compute values (ğœğ‘–,ğ‘— ) ğ‘— âˆˆğµ\ğ¶ â† SimComb(skğ‘– ,
ğµ, (ğœğ‘–,ğ‘— ) ğ‘— âˆˆğµâˆ©ğ¶ , pubğ‘– ). For each ğ‘— âˆˆ ğµ \ ğ¶, program ğ‘…sim (ğ‘–, ğ‘—) := ğœğ‘–,ğ‘— .
(c) Update the entry in ğ‘ˆ as (ğ‘–, skğ‘– , ğµ, (ğœğ‘–,ğ‘— ) ğ‘— âˆˆğµ , pubğ‘– ).
Finally, send (skğ‘– , (ğœğ‘–,ğ‘— ) ğ‘— âˆˆğµ , {ğœğ‘–,ğ‘˜ }ğ‘˜ ) to A as the
secret state, where {ğœğ‘–,ğ‘˜ }ğ‘˜ are all entries (if no
such entry is found, skip this) {(ğ‘–, ğœğ‘–,ğ‘˜ )} with the
same ğ‘–, retrieved from ğ‘‰ .
(2) If such an entries are not found in ğ‘ˆ or ğ‘‰ , then send
skğ‘– as the only secret state.
â€¢ The oracle SRec (ğ‘–, ğ‘…) is simulated as follows.
(1) If ğ‘– âˆˆ ğ» , then no non-trivial information is sent to the
adversary. However, based on whether the recovery
succeeds or not it needs to define ğ‘–â€™s output within
Out H . Therefore, it receives the responses ğœğ‘–,ğ‘— for each
corrupt ğ‘— âˆˆ ğ‘… âˆ© ğ¶ from the adversary. For each honest
guardian ğ‘— âˆˆ ğ‘… âˆ© ğ» , compute ğœğ‘–,ğ‘— = ğ‘…sim (ğ‘–, ğ‘—). Then
it recovers ğ‘  â† Recon(ğœ‘ğ‘– , ğœÂ®ğ‘… , ğ‘…) where ğœ‘ğ‘– is obtained
from ğ‘ˆ . It verifies whether ğ‘  is consistent with pkğ‘– . If
yes, then define the output of party-ğ‘– with Out H to be
ğ‘ , otherwise define it to be âŠ¥.
simulation is trivial, as nothing is sent to the adversary
(because the final output is private).
(2) If ğ‘– âˆˆ ğ¶, then for each honest guardian ğ‘— âˆˆ ğ‘… âˆ© ğ» ,
compute ğœğ‘–,ğ‘— = ğ‘…sim (ğ‘–, ğ‘—) and send ğœğ‘–,ğ‘— to ğ‘ƒğ‘– .
Now for any given honest party ğ‘— âˆˆ [ğ» ], let us define a bad event,
ğ‘—
EBad , to be when A queries SRO on (ğ‘–, sk ğ‘— ) for any ğ‘– âˆˆ ğ¶. Next,

ğ‘—âˆ—

Now, clearly Pr[EBreak ] â‰¥ Pr[EBad ] â‰¥ (1/ğ‘ ) Â· Pr[EBad ]. Pr[EBad ]
must be negligible because Pr[EBreak ] is negligible.
â–¡
There are two differences between Real and Ideal from Aâ€™s point
of view. (1) In Ideal, S implements the random oracle using SRO and
ğ‘…sim . The second difference (2) appears when ğ‘ƒğ‘– is corrupted after
ğ‘ƒğ‘– serves as the key owner in an execution of Î  Back . In Real, the
values (ğœğ‘–,ğ‘— ) ğ‘— âˆˆğµ\ğ¶ are chosen randomly, and ğœ™ğ‘– is computed as ğœ™ğ‘– =
Share(ğ‘ , (ğœğ‘–,ğ‘— ) ğ‘— âˆˆ [ğµ ] ). In Ideal, ğœ™ğ‘– is computed by SimShare(ğ¶ âˆ© ğµ),
and (ğœğ‘–,ğ‘— ) ğ‘— âˆˆğµ\ğ¶ is computed by SimComb(skğ‘– , (ğœğ‘–,ğ‘— ) ğ‘— âˆˆğµâˆ©ğ¶ , pubğ‘– ).
(1): S simulates the random oracle correctly if EBad does not
occur. For every distinct query that A makes to SRO , S samples
the response uniformly and independently at random. Furthermore,
if A queries SRO (ğ‘–, sk ğ‘— ) for some ğ‘— âˆˆ [ğ‘ ], the output will be the
same as ğœğ‘–,ğ‘— , which S provides on behalf of ğ‘ƒ ğ‘— whenever ğ‘ƒ ğ‘— serves
as a guardian for ğ‘ƒğ‘– . Finally, in SCor , S programs ğ‘…sim (ğ‘–, ğ‘—) to ğœğ‘–,ğ‘—
for every ğ‘— âˆˆ ğµ\ğ¶. The adversary has not yet queried ğ‘…sim on (ğ‘–, ğ‘—),
assuming that EBad does not happen. So the adversaryâ€™s view is
the same as if ğ‘…sim (ğ‘–, ğ‘—) were set to a random initial value and were
never reprogrammed.
(2): The distribution of ((ğœğ‘–,ğ‘— ) ğ‘— âˆˆğµ\ğ¶ , ğœ™ğ‘– ) is the same in Real and
Ideal due to the perfect adaptive simulation security of the secret
sharing scheme. The problem of distinguishing Real and Ideal exactly corresponds to the problem of distinguishing RealSh and
IdealSh.
This concludes the proof.
â–¡

7

EVALUATION

We present our empirical evaluations in this section.

ğ‘—

let EBad = âˆª ğ‘— EBad . We argue that this happens with negligible
probability in the lemma stated below.
Lemma 6.1. For any PPT adversary A, the probability of EBad
happening is negligible in ğœ†, as long as the problem PKeyGen is computationally hard.
Proof. In the reduction the challenger for PKeyGen samples
(skâˆ—, pkâˆ— ) â† KeyGen(1ğœ† ) and gives pkâˆ— to the reduction. The reductions simulate the ideal world experiment Ideal A with (skâˆ—, pkâˆ— ) =
(sk ğ‘— âˆ— , pk ğ‘— âˆ— ) for a uniform random ğ‘— âˆ— âˆˆ [ğ‘ ] as follows:
$

(1) Sample ğ‘— âˆ— â† [ğ‘ ].
(2) Set pk ğ‘— âˆ— = pkâˆ— . Implicitly, sk ğ‘— âˆ— = skâˆ— because every pk has a
unique sk for a standard KeyGen. Then sample (sk ğ‘— , pk ğ‘— ) â†
KeyGen(1ğœ† ) for every ğ‘— âˆˆ [ğ‘ ]\{ ğ‘— âˆ— } and send A (the SKR
Â®
adversary) the values pk
[ğ‘ ] .
(3) Now simulate the oracles SRO , SBack , SRec , SCor as above
in the Ideal A (1ğœ† , 1ğ‘ , ğ”„, KeyGen, Î SKR ) with the following
conditions:

7.1

Implementation and Setup

We implement our scheme in Rust utilizing the RustCryptoâ€™s ellipticcurves [13] library for cryptographic operations and tokio [27] for
network communication with âˆ¼ 2572 lines of code. We conduct
our experiments on Google Cloud Platform (GCP) with each entity
realized as a separate GCP N2D instance, with a 2.25 GHz AMD
EPYC CPU and 16 GB of RAM. We evaluate the performance of our
scheme in both LAN and WAN settings:
LAN setting: The GCP N2D instances for all parties are co-located
within the same geographical region, achieving an average bandwidth of 880.64 MB/s and a network latency of 1.3 ms.
WAN setting: The instances for all parties are geo-distributed.
This configuration yields an average bandwidth of 18.5 MB/s and a
network latency of 138.0 ms.
Each data point presented in our results represents the average
of 10 runs. We assess the performance of our system using four
different combinations of elliptic curves and hash functions. To
evaluate the scalability of our scheme, we conduct experiments by
varying the number of parties.

ANARKey: A New Approach to (Socially) Recover Keys

Figure 3: Compute cost comparison for creating a key backup and performing a key recovery for ğ‘› = 7 (ğ‘› âˆ’ 1 guardians),
considering {1, 2, 4} parallel threads.

7.2

Experimental Results

In this section, we evaluate the performance of our social key recovery scheme for key backup and recovery operations. Figure 3
illustrates the computation cost (excluding network time) for creating a key backup and performing a key recovery for ğ‘› = 7 parties
where ğ‘¡ = 3. The key-owner requires 0.5 - 3.5 ms to create a key
backup, depending on the selected elliptic curve and hash function.
With 4 parallel threads, the key backup cost is reduced to 0.2 - 1.1
ms. In the event of key loss, the key-owner can perform the key
recovery operation in 0.2 - 1.0 ms using a single thread, or 0.1 - 0.5
ms with 4 parallel threads.
We also evaluate the end-to-end performance of our key recovery scheme by running the key-owner and each guardian on
separate GCP instances in both LAN and WAN settings, with pointto-point communication channels between the key-owner and each
guardian. Table 1 presents the total time for key backup and recovery for different choices of elliptic curves and hash functions. As
expected, the time for both key backup and recovery operations
scales linearly with the number of parties. For instance, using K256SHA256 in the LAN setting, as ğ‘› increases from 3 to 11, the key
backup time rises linearly from 1.839 ms to 5.696 ms and the key
recovery time increases linearly from 0.83 ms to 1.347 ms. Similarly, using P521-SHA512 in the WAN setting, the key backup
time increases from 146.747 ms to 149.670 ms and the key recovery
time increases from 146.625 ms to 148.371 ms as ğ‘› varies from 3

to 11. This demonstrates the scalability of our protocol in both
regional (LAN) and geo-distributed (WAN) settings.

8

EXTENSIONS

In this section we discuss a number of extensions for our concrete
construction (our generic SKR protocol Î , given in Figure 2 instantiated with our BUSS scheme from Section 5.1) that maybe useful
in practice. We choose not to formalize this to keep the core ideas
simple.
Key Update. A natural question to consider is what happens
when a guardian performs a key update. To accommodate that, we
describe a simple mechanism to which can be easily incorporated
into our existing protocol as follows:
â€¢ Let us assume the old key of a guardian with identity-ğ‘— is
sk ğ‘— , and the updated key is skâ€²ğ‘— . For each key-owner with
identity-ğ‘–, guardian-ğ‘— computes the difference in the share
Î”ğ‘–,ğ‘— := H(ğ‘–, sk ğ‘— ) âˆ’ H(ğ‘–, skâ€²ğ‘— ) and send that to owner-ğ‘–.
â€¢ The owner implicitly defines the updated secret polynomial
from the BUSS scheme ğ‘“ğ‘–â€² (ğ‘¥) := ğ‘“ğ‘– (ğ‘¥) + Î”ğ‘–,ğ‘— ğ¿ ğ‘—,ğµ (ğ‘¥). where
ğ¿ ğ‘—,ğµ (ğ‘¥) is the Lagrange polynomial corresponding to point
ğ‘— and set ğµ.10
â€¢ Update the public values, such as ğ‘“ğ‘–â€² (âˆ’1) = ğ‘“ğ‘– (âˆ’1)+Î”ğ‘–,ğ‘— ğ¿ ğ‘—,ğµ (âˆ’1)
and so on.
10 Recall that, for each point ğ‘— â€² âˆˆ ğµ \ { ğ‘— } , ğ¿

â€²
ğ‘—,ğµ ( ğ‘— ) = 0 and at point ğ‘— : ğ¿ ğ‘—,ğµ ( ğ‘— ) = 1.

Aniket Kate, Pratyay Mukherjee, Hamza Saleem, Pratik Sarkar, and Bhaskar Roberts

EC-Hash

K256-SHA256

P256-SHA256

P384-SHA384

P521-SHA512

n
3
5
7
9
11
3
5
7
9
11
3
5
7
9
11
3
5
7
9
11

LAN
Backup Recovery
1.839
0.830
2.718
0.879
3.874
0.928
4.981
1.284
5.696
1.347
1.905
0.805
2.962
0.893
3.671
0.978
4.864
1.133
5.941
1.220
2.182
1.158
3.408
1.164
4.361
1.182
5.184
1.367
6.480
1.454
2.110
1.165
3.120
1.230
4.448
1.377
5.962
1.440
7.215
1.525

WAN
Backup Recovery
138.866 138.709
142.550 142.476
146.499 146.412
146.581 146.381
147.250 146.971
142.959 142.848
146.510 146.342
146.897 146.634
146.930 146.379
147.369 146.844
143.296 143.248
147.041 146.685
147.325 146.952
147.930 147.175
148.411 147.360
146.747 146.625
148.209 146.955
148.560 147.477
149.151 147.890
149.670 148.371

Table 1: End-to-end time in milliseconds for performing a
key backup and recovery for ğ‘› = 2ğ‘¡ + 1 (ğ‘› âˆ’ 1 guardians) in
both LAN and WAN settings.

Clearly, the new share of guardian-ğ‘— is ğ‘“ğ‘–â€² ( ğ‘—) = ğ‘“ğ‘– ( ğ‘—) + Î”ğ‘–,ğ‘— , and
for all other guardians ğ‘— â€² âˆˆ ğµ \ {ğ‘–} we have ğ‘“ğ‘–â€² ( ğ‘— â€² ) = ğ‘“ğ‘– ( ğ‘— â€² ), that
means the share remains unchanged. So, the procedure is completely oblivious to them, as they may not be even aware of the
update, which takes place only between the guardian-ğ‘— and the
corresponding key-owner, who needs to update only the public
values. Nevertheless, guardian-ğ‘— must contact all key-owners he is
supporting. Security wise, the key-owner knows Î”ğ‘–,ğ‘— which is not
a sensitive information.
Risk of Exposure. A practical concern with our approach might be
that, since each guardian needs to use their secret key for computing
each share, that makes their own key exposed in the memory for
a longer period. One simple way to mitigate this would be to use
another key just for this purpose. While this requires additional
storage, unlike our solution, still the requirement for total secret
storage is constant and independent of the number of key-owners
it supports. Note that, this will also eliminate the possibility of
so-called "domino effect" discussed in Section 1.3.
Cold wallets. While our solution is general and is also agnostic of
whether a hot or cold wallet is being used, in practice it is easier to
deploy in a hot wallet setting, where secret keys can directly used
to compute the shares. Cold wallets, instead never expose the key
to the memory, and instead just send out the computed signatures
for authorizing transactions directly. For such settings, computing
shares by hashing the secret keys would not work immediately, as
cold wallets are programmed to compute specific functions (such
as signatures). However, since most cold wallets (e.g. Ledger [15],
Trezor [29] etc.) implement RFC6979 specs [21], which specifies

deterministic signatures, we can make it work with our approach
as follows:
â€¢ The guardian-ğ‘— generates a deterministic signature ğœğ‘–,ğ‘— on
a specific message (Rec, ğ‘–, ğ‘—) o help backup/recover the key
of owner ğ‘–.
â€¢ Then guardian-ğ‘— participates in the SKR protocol (Fig. 2)
using ğœğ‘–,ğ‘— := H(ğœğ‘–,ğ‘— ), where H is a random oracle that maps
signatures to field elements.
It works because instead of the secret keys themselves it suffices
to use the deterministic signatures output by the cold-wallet on
the unique message. Each ğœğ‘–,ğ‘— is guaranteed to be random and
unpredictable due to the unforgeability guarantees of the coldwallet. Nonetheless, we remark that if a cold wallet implements a
randomized signature then this will not work, because the wallet
would yield different ğœğ‘–,ğ‘— values during backup and recovery, which
is undesirable. Further note that, this issue does not arise if the
above two-key approach is used.

9

CONCLUSION

We propose a simple and efficient protocol for socially backup and
recover keys within a community where each party holds a secret
key (and has a corresponding public key). Our solution uses a newly
introduced technique, that we formalize here as bottom-up secret
sharing, as the main underlying tool. Our design enables mutual
key backups within the community - where each party can act as a
backup guardian for multiple key owners, and no guardian needs
to store anything extra other than its own secret key.
We analyze our protocol in a formal framework, we put forward
in this work. While our framework is general enough, it does not
capture the so-called domino effect (Section 1.3). We leave formalizing that with a plausibly extended framework as an interesting
future work.
To the best of our knowledge, ours is the first effort to formalize
social recovery protocols. Additionally the mutual key back-up setting within a community of key holders has never been considered
earlier. Our protocol is very simple and also practically efficient, as
demonstrated by our empirical results. The new concept of bottomup secret sharing may be of independent interest.

REFERENCES
[1] Aptos. 2024. Aptos Keyless. https://aptos.dev/en/build/guides/aptos-keyless.
[2] Argent. 2025. How to Recover My Wallet with Guardians On-Chain (Complete Guide). https://support.argent.xyz/hc/en-us/articles/360007338877-Howto-recover-my-wallet-with-guardians-on-chain-complete-guide. Accessed:
2025-01-09.
[3] Leemon Baird, Sanjam Garg, Abhishek Jain, Pratyay Mukherjee, Rohit Sinha,
Mingyuan Wang, and Yinuo Zhang. 2023. Threshold Signatures in the Multiverse.
Cryptology ePrint Archive, Paper 2023/063. https://eprint.iacr.org/2023/063
https://eprint.iacr.org/2023/063.
[4] Mihir Bellare, Wei Dai, and Phillip Rogaway. 2020. Reimagining secret sharing:
Creating a safer and more versatile primitive by adding authenticity, correcting
errors, and reducing randomness requirements. Proceedings on Privacy Enhancing
Technologies (2020).
[5] BitGo. 2025. Wallet Recovery Guide. https://developers.bitgo.com/guides/wallets/
recover. Accessed: 2025-01-09.
[6] Sam Blackshear, Konstantinos Chalkias, Panagiotis Chatzigiannis, Riyaz Faizullabhoy, Irakliy Khaburzaniya, Eleftherios Kokoris-Kogias, Joshua Lind, David
Wong, and Tim Zakian. 2021. Reactive Key-Loss Protection in Blockchains. In
Financial Cryptography and Data Security. FC 2021 International Workshops CoDecFin, DeFi, VOTING, and WTSC, Virtual Event, March 5, 2021, Revised Selected
Papers (Lecture Notes in Computer Science, Vol. 12676), Matthew Bernhard, Andrea

ANARKey: A New Approach to (Socially) Recover Keys

Bracciali, Lewis Gudgeon, Thomas Haines, Ariah Klages-Mundt, Shinâ€™ichiro Matsuo, Daniel Perez, Massimiliano Sala, and Sam Werner (Eds.). Springer, 431â€“450.
[7] Dan Boneh, Ben Lynn, and Hovav Shacham. 2001. Short Signatures from the
Weil Pairing. 514â€“532. https://doi.org/10.1007/3-540-45682-1_30
[8] Vitalik Buterin. 2021. Why we need wide adoption of social recovery wallets.
https://vitalik.eth.limo/general/2021/01/11/recovery.html.
[9] Ran Canetti. 2000. Security and Composition of Multiparty Cryptographic
Protocols. 13, 1 (Jan. 2000), 143â€“202. https://doi.org/10.1007/s001459910006
[10] Panagiotis Chatzigiannis, Konstantinos Chalkias, Aniket Kate, Easwar Vivek
Mangipudi, Mohsen Minaei, and Mainack Mondal. 2023. SoK: Web3 Recovery
Mechanisms. IACR Cryptol. ePrint Arch. (2023), 1575. https://eprint.iacr.org/
2023/1575
[11] Cypherock. 2025. Cypherock Documentation. https://docs.cypherock.com/.
Accessed: 2025-01-09.
[12] Poulami Das, Sebastian Faust, and Julian Loss. 2019. A Formal Treatment of
Deterministic Wallets. 651â€“668. https://doi.org/10.1145/3319535.3354236
[13] RustCrypto Developers. 2025. Elliptic Curves Implementation. https://github.
com/RustCrypto/elliptic-curves. Accessed: 2025-01-09.
[14] Dash Core Group. 2025. Dash: A Privacy-Centric Cryptocurrency. https://www.
exodus.com/assets/docs/dash-whitepaper.pdf. Accessed: 2025-01-09.
[15] Ledger. [n. d.]. Ledger: Hardware Wallet for Cryptocurrency Security. https:
//www.ledger.com/. Accessed: 2025-01-08.
[16] Yehuda Lindell. 2017. How to Simulate It - A Tutorial on the Simulation Proof
Technique. In Tutorials on the Foundations of Cryptography, Yehuda Lindell (Ed.).
Springer International Publishing, 277â€“346. https://doi.org/10.1007/978-3-31957048-8_6
[17] Yehuda Lindell. 2023. Cryptography and MPC in Coinbase Wallet as a Service
(WaaS). https://www.coinbase.com/blog/digital-asset-management-with-mpcwhitepaper
[18] Ryan Little, Lucy Qin, and Mayank Varia. 2024. Secure Account Recovery for a
Privacy-Preserving Web Service. In 33rd USENIX Security Symposium, USENIX
Security 2024, Philadelphia, PA, USA, August 14-16, 2024, Davide Balzarotti and

Wenyuan Xu (Eds.). USENIX Association. https://www.usenix.org/conference/
usenixsecurity24/presentation/little
[19] MetaMask. 2025. MetaMask Documentation. https://docs.metamask.io/. Accessed: 2025-01-09.
[20] Allan B. Pedin, Nazli Siasi, and Mohammad Sameni. 2023. Smart ContractBased Social Recovery Wallet Management Scheme for Digital Assets. In Proceedings of the 2023 ACM Southeast Conference (Virtual Event, USA) (ACM
SE â€™23). Association for Computing Machinery, New York, NY, USA, 177â€“181.
https://doi.org/10.1145/3564746.3587016
[21] T. Pornin. 2013. RFC 6979: Deterministic Usage of the Digital Signature Algorithm
(DSA) and Elliptic Curve Digital Signature Algorithm (ECDSA).
[22] Sequence. 2025. Sequence Documentation. https://docs.sequence.xyz/. Accessed:
2025-01-09.
[23] Adi Shamir. 1979. How to share a secret. Commun. ACM 22, 11 (1979), 612â€“613.
[24] Sui. 2023. zkLogin. https://docs.sui.io/concepts/cryptography/zklogin.
[25] Jacob Swambo and Antoine Poinsot. 2021. Risk Framework for Bitcoin Custody
Operation with the Revault Protocol. In Financial Cryptography and Data Security.
FC 2021 International Workshops, Matthew Bernhard, Andrea Bracciali, Lewis
Gudgeon, Thomas Haines, Ariah Klages-Mundt, Shinâ€™ichiro Matsuo, Daniel
Perez, Massimiliano Sala, and Sam Werner (Eds.). Springer Berlin Heidelberg,
Berlin, Heidelberg, 3â€“20.
[26] New York Times. [n. d.]. Tens of billions worth of Bitcoin have been locked by people who forgot their key. https://www.nytimes.com/2021/01/13/business/tensof-billions-worth-of-bitcoin-have-been-locked-by-people-who-forgot-theirkey.html.
[27] Tokio. 2025. Tokio: An Async Runtime for Rust. https://tokio.rs/. Accessed:
2025-01-09.
[28] Torus. 2025. Torus Documentation. https://docs.tor.us/. Accessed: 2025-01-09.
[29] Trezor. [n. d.]. Trezor: Hardware Wallet for Secure Cryptocurrency Storage.
https://trezor.io/. Accessed: 2025-01-08.
[30] Zengo. 2025. Zengo: The Crypto Wallet for Everyone. https://zengo.com/.
Accessed: 2025-01-09.

